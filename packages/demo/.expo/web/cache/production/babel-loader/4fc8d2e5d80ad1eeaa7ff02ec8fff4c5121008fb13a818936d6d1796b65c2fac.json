{"ast":null,"code":"'use strict';export function elementsThatOverlapOffsets(offsets,props,getFrameMetrics,zoomScale){if(zoomScale===void 0){zoomScale=1;}var itemCount=props.getItemCount(props.data);var result=[];for(var offsetIndex=0;offsetIndex<offsets.length;offsetIndex++){var currentOffset=offsets[offsetIndex];var left=0;var right=itemCount-1;while(left<=right){var mid=left+(right-left>>>1);var frame=getFrameMetrics(mid,props);var scaledOffsetStart=frame.offset*zoomScale;var scaledOffsetEnd=(frame.offset+frame.length)*zoomScale;if(mid===0&&currentOffset<scaledOffsetStart||mid!==0&&currentOffset<=scaledOffsetStart){right=mid-1;}else if(currentOffset>scaledOffsetEnd){left=mid+1;}else{result[offsetIndex]=mid;break;}}}return result;}export function newRangeCount(prev,next){return next.last-next.first+1-Math.max(0,1+Math.min(next.last,prev.last)-Math.max(next.first,prev.first));}export function computeWindowedRenderLimits(props,maxToRenderPerBatch,windowSize,prev,getFrameMetricsApprox,scrollMetrics){var itemCount=props.getItemCount(props.data);if(itemCount===0){return{first:0,last:-1};}var offset=scrollMetrics.offset,velocity=scrollMetrics.velocity,visibleLength=scrollMetrics.visibleLength,_scrollMetrics$zoomSc=scrollMetrics.zoomScale,zoomScale=_scrollMetrics$zoomSc===void 0?1:_scrollMetrics$zoomSc;var visibleBegin=Math.max(0,offset);var visibleEnd=visibleBegin+visibleLength;var overscanLength=(windowSize-1)*visibleLength;var leadFactor=0.5;var fillPreference=velocity>1?'after':velocity<-1?'before':'none';var overscanBegin=Math.max(0,visibleBegin-(1-leadFactor)*overscanLength);var overscanEnd=Math.max(0,visibleEnd+leadFactor*overscanLength);var lastItemOffset=getFrameMetricsApprox(itemCount-1,props).offset*zoomScale;if(lastItemOffset<overscanBegin){return{first:Math.max(0,itemCount-1-maxToRenderPerBatch),last:itemCount-1};}var _elementsThatOverlapO=elementsThatOverlapOffsets([overscanBegin,visibleBegin,visibleEnd,overscanEnd],props,getFrameMetricsApprox,zoomScale),overscanFirst=_elementsThatOverlapO[0],first=_elementsThatOverlapO[1],last=_elementsThatOverlapO[2],overscanLast=_elementsThatOverlapO[3];overscanFirst=overscanFirst==null?0:overscanFirst;first=first==null?Math.max(0,overscanFirst):first;overscanLast=overscanLast==null?itemCount-1:overscanLast;last=last==null?Math.min(overscanLast,first+maxToRenderPerBatch-1):last;var visible={first:first,last:last};var newCellCount=newRangeCount(prev,visible);while(true){if(first<=overscanFirst&&last>=overscanLast){break;}var maxNewCells=newCellCount>=maxToRenderPerBatch;var firstWillAddMore=first<=prev.first||first>prev.last;var firstShouldIncrement=first>overscanFirst&&(!maxNewCells||!firstWillAddMore);var lastWillAddMore=last>=prev.last||last<prev.first;var lastShouldIncrement=last<overscanLast&&(!maxNewCells||!lastWillAddMore);if(maxNewCells&&!firstShouldIncrement&&!lastShouldIncrement){break;}if(firstShouldIncrement&&!(fillPreference==='after'&&lastShouldIncrement&&lastWillAddMore)){if(firstWillAddMore){newCellCount++;}first--;}if(lastShouldIncrement&&!(fillPreference==='before'&&firstShouldIncrement&&firstWillAddMore)){if(lastWillAddMore){newCellCount++;}last++;}}if(!(last>=first&&first>=0&&last<itemCount&&first>=overscanFirst&&last<=overscanLast&&first<=visible.first&&last>=visible.last)){throw new Error('Bad window calculation '+JSON.stringify({first:first,last:last,itemCount:itemCount,overscanFirst:overscanFirst,overscanLast:overscanLast,visible:visible}));}return{first:first,last:last};}export function keyExtractor(item,index){if(typeof item==='object'&&(item==null?void 0:item.key)!=null){return item.key;}if(typeof item==='object'&&(item==null?void 0:item.id)!=null){return item.id;}return String(index);}","map":{"version":3,"names":["elementsThatOverlapOffsets","offsets","props","getFrameMetrics","zoomScale","itemCount","getItemCount","data","result","offsetIndex","length","currentOffset","left","right","mid","frame","scaledOffsetStart","offset","scaledOffsetEnd","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","maxToRenderPerBatch","windowSize","getFrameMetricsApprox","scrollMetrics","velocity","visibleLength","_scrollMetrics$zoomSc","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","JSON","stringify","keyExtractor","item","index","key","id","String"],"sources":["/Users/josh/src/ui/node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(offsets, props, getFrameMetrics, zoomScale) {\n  if (zoomScale === void 0) {\n    zoomScale = 1;\n  }\n  var itemCount = props.getItemCount(props.data);\n  var result = [];\n  for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    var currentOffset = offsets[offsetIndex];\n    var left = 0;\n    var right = itemCount - 1;\n    while (left <= right) {\n      // eslint-disable-next-line no-bitwise\n      var mid = left + (right - left >>> 1);\n      var frame = getFrameMetrics(mid, props);\n      var scaledOffsetStart = frame.offset * zoomScale;\n      var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\n      if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {\n      first: 0,\n      last: -1\n    };\n  }\n  var offset = scrollMetrics.offset,\n    velocity = scrollMetrics.velocity,\n    visibleLength = scrollMetrics.visibleLength,\n    _scrollMetrics$zoomSc = scrollMetrics.zoomScale,\n    zoomScale = _scrollMetrics$zoomSc === void 0 ? 1 : _scrollMetrics$zoomSc;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),\n    overscanFirst = _elementsThatOverlapO[0],\n    first = _elementsThatOverlapO[1],\n    last = _elementsThatOverlapO[2],\n    overscanLast = _elementsThatOverlapO[3];\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first,\n    last\n  };\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  var newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first,\n      last,\n      itemCount,\n      overscanFirst,\n      overscanLast,\n      visible\n    }));\n  }\n  return {\n    first,\n    last\n  };\n}\nexport function keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n  return String(index);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}