{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import inRange from'lodash/inRange';import XDate from'xdate';import constants from'../commons/constants';export var HOUR_BLOCK_HEIGHT=100;var OVERLAP_EVENTS_SPACINGS=10;var RIGHT_EDGE_SPACING=10;function buildEvent(event,left,width,_ref){var _ref$dayStart=_ref.dayStart,dayStart=_ref$dayStart===void 0?0:_ref$dayStart,_ref$hourBlockHeight=_ref.hourBlockHeight,hourBlockHeight=_ref$hourBlockHeight===void 0?HOUR_BLOCK_HEIGHT:_ref$hourBlockHeight;var startTime=new XDate(event.start);var endTime=event.end?new XDate(event.end):new XDate(startTime).addHours(1);var dayStartTime=new XDate(startTime).clearTime();return _objectSpread(_objectSpread({},event),{},{top:(dayStartTime.diffHours(startTime)-dayStart)*hourBlockHeight,height:startTime.diffHours(endTime)*hourBlockHeight,width:width,left:left});}function hasCollision(a,b){return a.end>b.start&&a.start<b.end;}function calcColumnSpan(event,columnIndex,columns){var colSpan=1;for(var i=columnIndex+1;i<columns.length;i++){var column=columns[i];var foundCollision=column.find(function(ev){return hasCollision(event,ev);});if(foundCollision){return colSpan;}colSpan++;}return colSpan;}function packOverlappingEventGroup(columns,calculatedEvents,populateOptions){var _populateOptions$scre=populateOptions.screenWidth,screenWidth=_populateOptions$scre===void 0?constants.screenWidth:_populateOptions$scre,_populateOptions$righ=populateOptions.rightEdgeSpacing,rightEdgeSpacing=_populateOptions$righ===void 0?RIGHT_EDGE_SPACING:_populateOptions$righ,_populateOptions$over=populateOptions.overlapEventsSpacing,overlapEventsSpacing=_populateOptions$over===void 0?OVERLAP_EVENTS_SPACINGS:_populateOptions$over;columns.forEach(function(column,columnIndex){column.forEach(function(event){var totalWidth=screenWidth-rightEdgeSpacing;var columnSpan=calcColumnSpan(event,columnIndex,columns);var eventLeft=columnIndex/columns.length*totalWidth;var eventWidth=totalWidth*(columnSpan/columns.length);if(columnIndex+columnSpan<=columns.length-1){eventWidth-=overlapEventsSpacing;}calculatedEvents.push(buildEvent(event,eventLeft,eventWidth,populateOptions));});});}export function populateEvents(_events,populateOptions){var lastEnd=null;var columns=[];var calculatedEvents=[];var events=_events.map(function(ev,index){return _objectSpread(_objectSpread({},ev),{},{index:index});}).sort(function(a,b){if(a.start<b.start)return-1;if(a.start>b.start)return 1;if(a.end<b.end)return-1;if(a.end>b.end)return 1;return 0;});events.forEach(function(ev){if(lastEnd!==null&&ev.start>=lastEnd){packOverlappingEventGroup(columns,calculatedEvents,populateOptions);columns=[];lastEnd=null;}var placed=false;for(var i=0;i<columns.length;i++){var col=columns[i];if(!hasCollision(col[col.length-1],ev)){col.push(ev);placed=true;break;}}if(!placed){columns.push([ev]);}if(lastEnd===null||ev.end>lastEnd){lastEnd=ev.end;}});if(columns.length>0){packOverlappingEventGroup(columns,calculatedEvents,populateOptions);}return calculatedEvents;}export function buildUnavailableHoursBlocks(){var unavailableHours=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var options=arguments.length>1?arguments[1]:undefined;var _ref2=options||{},_ref2$hourBlockHeight=_ref2.hourBlockHeight,hourBlockHeight=_ref2$hourBlockHeight===void 0?HOUR_BLOCK_HEIGHT:_ref2$hourBlockHeight,_ref2$dayStart=_ref2.dayStart,dayStart=_ref2$dayStart===void 0?0:_ref2$dayStart,_ref2$dayEnd=_ref2.dayEnd,dayEnd=_ref2$dayEnd===void 0?24:_ref2$dayEnd;var totalDayHours=dayEnd-dayStart;var totalDayHeight=(dayEnd-dayStart)*hourBlockHeight;return unavailableHours.map(function(hours){if(!inRange(hours.start,0,25)||!inRange(hours.end,0,25)){console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');return undefined;}if(hours.start>=hours.end){console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');return undefined;}var startFixed=Math.max(hours.start,dayStart);var endFixed=Math.min(hours.end,dayEnd);return{top:(startFixed-dayStart)/totalDayHours*totalDayHeight,height:(endFixed-startFixed)*hourBlockHeight};}).filter(Boolean);}","map":{"version":3,"names":["inRange","XDate","constants","HOUR_BLOCK_HEIGHT","OVERLAP_EVENTS_SPACINGS","RIGHT_EDGE_SPACING","buildEvent","event","left","width","_ref","_ref$dayStart","dayStart","_ref$hourBlockHeight","hourBlockHeight","startTime","start","endTime","end","addHours","dayStartTime","clearTime","_objectSpread","top","diffHours","height","hasCollision","a","b","calcColumnSpan","columnIndex","columns","colSpan","i","length","column","foundCollision","find","ev","packOverlappingEventGroup","calculatedEvents","populateOptions","_populateOptions$scre","screenWidth","_populateOptions$righ","rightEdgeSpacing","_populateOptions$over","overlapEventsSpacing","forEach","totalWidth","columnSpan","eventLeft","eventWidth","push","populateEvents","_events","lastEnd","events","map","index","sort","placed","col","buildUnavailableHoursBlocks","unavailableHours","arguments","undefined","options","_ref2","_ref2$hourBlockHeight","_ref2$dayStart","_ref2$dayEnd","dayEnd","totalDayHours","totalDayHeight","hours","console","error","startFixed","Math","max","endFixed","min","filter","Boolean"],"sources":["/Users/josh/src/ui/node_modules/react-native-calendars/src/timeline/Packer.js"],"sourcesContent":["import inRange from 'lodash/inRange';\nimport XDate from 'xdate';\nimport constants from '../commons/constants';\nexport const HOUR_BLOCK_HEIGHT = 100;\nconst OVERLAP_EVENTS_SPACINGS = 10;\nconst RIGHT_EDGE_SPACING = 10;\nfunction buildEvent(event, left, width, { dayStart = 0, hourBlockHeight = HOUR_BLOCK_HEIGHT }) {\n    const startTime = new XDate(event.start);\n    const endTime = event.end ? new XDate(event.end) : new XDate(startTime).addHours(1);\n    const dayStartTime = new XDate(startTime).clearTime();\n    return {\n        ...event,\n        top: (dayStartTime.diffHours(startTime) - dayStart) * hourBlockHeight,\n        height: startTime.diffHours(endTime) * hourBlockHeight,\n        width,\n        left\n    };\n}\nfunction hasCollision(a, b) {\n    return a.end > b.start && a.start < b.end;\n}\nfunction calcColumnSpan(event, columnIndex, columns) {\n    let colSpan = 1;\n    for (let i = columnIndex + 1; i < columns.length; i++) {\n        const column = columns[i];\n        const foundCollision = column.find(ev => hasCollision(event, ev));\n        if (foundCollision) {\n            return colSpan;\n        }\n        colSpan++;\n    }\n    return colSpan;\n}\nfunction packOverlappingEventGroup(columns, calculatedEvents, populateOptions) {\n    const { screenWidth = constants.screenWidth, rightEdgeSpacing = RIGHT_EDGE_SPACING, overlapEventsSpacing = OVERLAP_EVENTS_SPACINGS } = populateOptions;\n    columns.forEach((column, columnIndex) => {\n        column.forEach(event => {\n            const totalWidth = screenWidth - rightEdgeSpacing;\n            const columnSpan = calcColumnSpan(event, columnIndex, columns);\n            const eventLeft = (columnIndex / columns.length) * totalWidth;\n            let eventWidth = totalWidth * (columnSpan / columns.length);\n            if (columnIndex + columnSpan <= columns.length - 1) {\n                eventWidth -= overlapEventsSpacing;\n            }\n            calculatedEvents.push(buildEvent(event, eventLeft, eventWidth, populateOptions));\n        });\n    });\n}\nexport function populateEvents(_events, populateOptions) {\n    let lastEnd = null;\n    let columns = [];\n    const calculatedEvents = [];\n    const events = _events\n        .map((ev, index) => ({ ...ev, index: index }))\n        .sort(function (a, b) {\n        if (a.start < b.start)\n            return -1;\n        if (a.start > b.start)\n            return 1;\n        if (a.end < b.end)\n            return -1;\n        if (a.end > b.end)\n            return 1;\n        return 0;\n    });\n    events.forEach(function (ev) {\n        // Reset recent overlapping event group and start a new one\n        if (lastEnd !== null && ev.start >= lastEnd) {\n            packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n            columns = [];\n            lastEnd = null;\n        }\n        // Place current event in the right column where it doesn't overlap\n        let placed = false;\n        for (let i = 0; i < columns.length; i++) {\n            const col = columns[i];\n            if (!hasCollision(col[col.length - 1], ev)) {\n                col.push(ev);\n                placed = true;\n                break;\n            }\n        }\n        // If curr event wasn't placed in any of the columns, create a new column for it\n        if (!placed) {\n            columns.push([ev]);\n        }\n        if (lastEnd === null || ev.end > lastEnd) {\n            lastEnd = ev.end;\n        }\n    });\n    if (columns.length > 0) {\n        packOverlappingEventGroup(columns, calculatedEvents, populateOptions);\n    }\n    return calculatedEvents;\n}\nexport function buildUnavailableHoursBlocks(unavailableHours = [], options) {\n    const { hourBlockHeight = HOUR_BLOCK_HEIGHT, dayStart = 0, dayEnd = 24 } = options || {};\n    const totalDayHours = dayEnd - dayStart;\n    const totalDayHeight = (dayEnd - dayStart) * hourBlockHeight;\n    return (unavailableHours\n        .map(hours => {\n        if (!inRange(hours.start, 0, 25) || !inRange(hours.end, 0, 25)) {\n            console.error('Calendar Timeline unavailableHours is invalid. Hours should be between 0 and 24');\n            return undefined;\n        }\n        if (hours.start >= hours.end) {\n            console.error('Calendar Timeline availableHours is invalid. start hour should be earlier than end hour');\n            return undefined;\n        }\n        const startFixed = Math.max(hours.start, dayStart);\n        const endFixed = Math.min(hours.end, dayEnd);\n        return {\n            top: ((startFixed - dayStart) / totalDayHours) * totalDayHeight,\n            height: (endFixed - startFixed) * hourBlockHeight\n        };\n    })\n        // Note: this filter falsy values (undefined blocks)\n        .filter(Boolean));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}