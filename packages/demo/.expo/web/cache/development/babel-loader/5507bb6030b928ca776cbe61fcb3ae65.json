{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { State } from '../../State';\nimport { PointerType } from '../interfaces';\nimport PointerTracker from './PointerTracker';\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    _classCallCheck(this, GestureHandlerOrchestrator);\n    _defineProperty(this, \"gestureHandlers\", []);\n    _defineProperty(this, \"awaitingHandlers\", []);\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n  _createClass(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_VALUE);\n    }\n  }, {\n    key: \"removeHandlerFromOrchestrator\",\n    value: function removeHandlerFromOrchestrator(handler) {\n      this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n      this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n        if (!handler) {\n          continue;\n        }\n        if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n          this.gestureHandlers.splice(i, 1);\n          this.cleanHandler(handler);\n        }\n      }\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n      var hasToWait = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler && !_this.isFinished(otherHandler.getState()) && _this.shouldHandlerWaitForOther(handler, otherHandler)) {\n          hasToWait = true;\n          return;\n        }\n      });\n      return hasToWait;\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler) {\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n      } else if (handler.getState() !== State.CANCELLED && handler.getState() !== State.FAILED) {\n        if (this.shouldActivate(handler)) {\n          this.makeActive(handler);\n        } else {\n          switch (handler.getState()) {\n            case State.ACTIVE:\n              handler.fail();\n              break;\n            case State.BEGAN:\n              handler.cancel();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"shouldActivate\",\n    value: function shouldActivate(handler) {\n      for (var otherHandler of this.gestureHandlers) {\n        if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      for (var i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {\n          this.cleanHandler(this.awaitingHandlers[i]);\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n      var _this2 = this;\n      if (!handler.isEnabled() && !sendIfDisabled) {\n        return;\n      }\n      this.handlingChangeSemaphore += 1;\n      if (this.isFinished(newState)) {\n        this.awaitingHandlers.forEach(function (otherHandler) {\n          if (_this2.shouldHandlerWaitForOther(otherHandler, handler)) {\n            if (newState === State.END) {\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n              if (otherHandler.getState() === State.END) {\n                otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n              }\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(false);\n            } else {\n              _this2.tryActivate(otherHandler);\n            }\n          }\n        });\n      }\n      if (newState === State.ACTIVE) {\n        this.tryActivate(handler);\n      } else if (oldState === State.ACTIVE || oldState === State.END) {\n        if (handler.isActive()) {\n          handler.sendEvent(newState, oldState);\n        } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n          handler.sendEvent(newState, State.BEGAN);\n        }\n      } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n        handler.sendEvent(newState, oldState);\n      }\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n      if (this.awaitingHandlers.indexOf(handler) < 0) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler) {\n      var _this3 = this;\n      var currentState = handler.getState();\n      handler.setActive(true);\n      handler.setShouldResetProgress(true);\n      handler.setActivationIndex(this.activationIndex++);\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n          this.gestureHandlers[i].cancel();\n        }\n      }\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(true);\n        }\n      });\n      handler.sendEvent(State.ACTIVE, State.BEGAN);\n      if (currentState !== State.ACTIVE) {\n        handler.sendEvent(State.END, State.ACTIVE);\n        if (currentState !== State.END) {\n          handler.sendEvent(State.UNDETERMINED, State.END);\n        }\n      }\n      if (handler.isAwaiting()) {\n        handler.setAwaiting(false);\n        for (var _i = 0; _i < this.awaitingHandlers.length; ++_i) {\n          if (this.awaitingHandlers[_i] === handler) {\n            this.awaitingHandlers.splice(_i, 1);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      var alreadyExists = false;\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n      if (alreadyExists) {\n        return;\n      }\n      this.awaitingHandlers.push(handler);\n      handler.setAwaiting(true);\n      handler.setActivationIndex(this.activationIndex++);\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      var alreadyExists = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n      if (alreadyExists) {\n        return;\n      }\n      this.gestureHandlers.push(handler);\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n      if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === State.ACTIVE)) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getDelegate().getView() !== otherHandler.getDelegate().getView()) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      var overlap = false;\n      handlerPointers.forEach(function (pointer) {\n        var handlerX = handler.getTracker().getLastX(pointer);\n        var handlerY = handler.getTracker().getLastY(pointer);\n        if (handler.getDelegate().isPointerInBounds({\n          x: handlerX,\n          y: handlerY\n        }) && otherHandler.getDelegate().isPointerInBounds({\n          x: handlerX,\n          y: handlerY\n        })) {\n          overlap = true;\n        }\n      });\n      otherPointers.forEach(function (pointer) {\n        var otherX = otherHandler.getTracker().getLastX(pointer);\n        var otherY = otherHandler.getTracker().getLastY(pointer);\n        if (handler.getDelegate().isPointerInBounds({\n          x: otherX,\n          y: otherY\n        }) && otherHandler.getDelegate().isPointerInBounds({\n          x: otherX,\n          y: otherY\n        })) {\n          overlap = true;\n        }\n      });\n      return overlap;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === State.END || state === State.FAILED || state === State.CANCELLED;\n    }\n  }, {\n    key: \"cancelMouseAndPenGestures\",\n    value: function cancelMouseAndPenGestures(currentHandler) {\n      this.gestureHandlers.forEach(function (handler) {\n        if (handler.getPointerType() !== PointerType.MOUSE && handler.getPointerType() !== PointerType.PEN) {\n          return;\n        }\n        if (handler !== currentHandler) {\n          handler.cancel();\n        } else {\n          handler.getTracker().resetTracker();\n        }\n      });\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!GestureHandlerOrchestrator.instance) {\n        GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n      }\n      return GestureHandlerOrchestrator.instance;\n    }\n  }]);\n  return GestureHandlerOrchestrator;\n}();\nexport { GestureHandlerOrchestrator as default };\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"sources":["GestureHandlerOrchestrator.ts"],"names":["State","PointerType","PointerTracker","GestureHandlerOrchestrator","constructor","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","gestureHandlers","splice","indexOf","awaitingHandlers","i","length","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","isEnabled","END","sendEvent","isActive","UNDETERMINED","currentState","setShouldResetProgress","activationIndex","alreadyExists","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getDelegate","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","isPointerInBounds","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","MOUSE","PEN","resetTracker","getInstance","instance"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getDelegate().getView() !== otherHandler.getDelegate().getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getDelegate().isPointerInBounds({ x: handlerX, y: handlerY }) &&\n        otherHandler\n          .getDelegate()\n          .isPointerInBounds({ x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getDelegate().isPointerInBounds({ x: otherX, y: otherY }) &&\n        otherHandler.getDelegate().isPointerInBounds({ x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}