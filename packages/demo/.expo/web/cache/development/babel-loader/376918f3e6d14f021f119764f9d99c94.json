{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport CircularBuffer from './CircularBuffer';\nimport LeastSquareSolver from './LeastSquareSolver';\nvar VelocityTracker = function () {\n  function VelocityTracker() {\n    _classCallCheck(this, VelocityTracker);\n    _defineProperty(this, \"assumePointerMoveStoppedMilliseconds\", 40);\n    _defineProperty(this, \"historySize\", 20);\n    _defineProperty(this, \"horizonMilliseconds\", 300);\n    _defineProperty(this, \"minSampleSize\", 3);\n    _defineProperty(this, \"samples\", void 0);\n    this.samples = new CircularBuffer(this.historySize);\n  }\n  _createClass(VelocityTracker, [{\n    key: \"add\",\n    value: function add(event) {\n      this.samples.push(event);\n    }\n  }, {\n    key: \"getVelocityEstimate\",\n    value: function getVelocityEstimate() {\n      var x = [];\n      var y = [];\n      var w = [];\n      var time = [];\n      var sampleCount = 0;\n      var index = this.samples.size - 1;\n      var newestSample = this.samples.get(index);\n      if (!newestSample) {\n        return null;\n      }\n      var previousSample = newestSample;\n      while (sampleCount < this.samples.size) {\n        var sample = this.samples.get(index);\n        var age = newestSample.time - sample.time;\n        var delta = Math.abs(sample.time - previousSample.time);\n        previousSample = sample;\n        if (age > this.horizonMilliseconds || delta > this.assumePointerMoveStoppedMilliseconds) {\n          break;\n        }\n        x.push(sample.x);\n        y.push(sample.y);\n        w.push(1);\n        time.push(-age);\n        sampleCount++;\n        index--;\n      }\n      if (sampleCount >= this.minSampleSize) {\n        var xSolver = new LeastSquareSolver(time, x, w);\n        var xFit = xSolver.solve(2);\n        if (xFit !== null) {\n          var ySolver = new LeastSquareSolver(time, y, w);\n          var yFit = ySolver.solve(2);\n          if (yFit !== null) {\n            var xVelocity = xFit.coefficients[1] * 1000;\n            var yVelocity = yFit.coefficients[1] * 1000;\n            return [xVelocity, yVelocity];\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"getVelocity\",\n    value: function getVelocity() {\n      var estimate = this.getVelocityEstimate();\n      if (estimate !== null) {\n        return estimate;\n      }\n      return [0, 0];\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.samples.clear();\n    }\n  }]);\n  return VelocityTracker;\n}();\nexport { VelocityTracker as default };","map":{"version":3,"sources":["VelocityTracker.ts"],"names":["CircularBuffer","LeastSquareSolver","VelocityTracker","constructor","samples","historySize","add","event","push","getVelocityEstimate","x","y","w","time","sampleCount","index","size","newestSample","get","previousSample","sample","age","delta","Math","abs","horizonMilliseconds","assumePointerMoveStoppedMilliseconds","minSampleSize","xSolver","xFit","solve","ySolver","yFit","xVelocity","coefficients","yVelocity","getVelocity","estimate","reset","clear"],"mappings":"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","sourcesContent":["import { AdaptedEvent } from '../interfaces';\nimport CircularBuffer from './CircularBuffer';\nimport LeastSquareSolver from './LeastSquareSolver';\n\nexport default class VelocityTracker {\n  private assumePointerMoveStoppedMilliseconds = 40;\n  private historySize = 20;\n  private horizonMilliseconds = 300;\n  private minSampleSize = 3;\n\n  private samples: CircularBuffer<AdaptedEvent>;\n\n  constructor() {\n    this.samples = new CircularBuffer<AdaptedEvent>(this.historySize);\n  }\n\n  public add(event: AdaptedEvent): void {\n    this.samples.push(event);\n  }\n\n  /// Returns an estimate of the velocity of the object being tracked by the\n  /// tracker given the current information available to the tracker.\n  ///\n  /// Information is added using [addPosition].\n  ///\n  /// Returns null if there is no data on which to base an estimate.\n  private getVelocityEstimate(): [number, number] | null {\n    const x = [];\n    const y = [];\n    const w = [];\n    const time = [];\n\n    let sampleCount = 0;\n    let index = this.samples.size - 1;\n    const newestSample = this.samples.get(index);\n    if (!newestSample) {\n      return null;\n    }\n\n    let previousSample = newestSample;\n\n    // Starting with the most recent PointAtTime sample, iterate backwards while\n    // the samples represent continuous motion.\n    while (sampleCount < this.samples.size) {\n      const sample = this.samples.get(index);\n\n      const age = newestSample.time - sample.time;\n      const delta = Math.abs(sample.time - previousSample.time);\n      previousSample = sample;\n\n      if (\n        age > this.horizonMilliseconds ||\n        delta > this.assumePointerMoveStoppedMilliseconds\n      ) {\n        break;\n      }\n\n      x.push(sample.x);\n      y.push(sample.y);\n      w.push(1);\n      time.push(-age);\n\n      sampleCount++;\n      index--;\n    }\n\n    if (sampleCount >= this.minSampleSize) {\n      const xSolver = new LeastSquareSolver(time, x, w);\n      const xFit = xSolver.solve(2);\n\n      if (xFit !== null) {\n        const ySolver = new LeastSquareSolver(time, y, w);\n        const yFit = ySolver.solve(2);\n\n        if (yFit !== null) {\n          const xVelocity = xFit.coefficients[1] * 1000;\n          const yVelocity = yFit.coefficients[1] * 1000;\n\n          return [xVelocity, yVelocity];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public getVelocity(): [number, number] {\n    const estimate = this.getVelocityEstimate();\n    if (estimate !== null) {\n      return estimate;\n    }\n    return [0, 0];\n  }\n\n  public reset(): void {\n    this.samples.clear();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}