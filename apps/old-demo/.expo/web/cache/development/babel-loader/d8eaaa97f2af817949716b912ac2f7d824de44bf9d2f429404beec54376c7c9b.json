{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linkTo = exports.setParams = exports.canDismiss = exports.canGoBack = exports.goBack = exports.dismissAll = exports.replace = exports.dismiss = exports.push = exports.navigate = void 0;\nvar native_1 = require(\"@react-navigation/native\");\nvar Linking = __importStar(require(\"expo-linking\"));\nvar href_1 = require(\"../link/href\");\nvar path_1 = require(\"../link/path\");\nvar url_1 = require(\"../utils/url\");\nfunction assertIsReady(store) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');\n  }\n}\nfunction navigate(url) {\n  return this.linkTo((0, href_1.resolveHref)(url), 'NAVIGATE');\n}\nexports.navigate = navigate;\nfunction push(url) {\n  return this.linkTo((0, href_1.resolveHref)(url), 'PUSH');\n}\nexports.push = push;\nfunction dismiss(count) {\n  var _this$navigationRef;\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : _this$navigationRef.dispatch(native_1.StackActions.pop(count));\n}\nexports.dismiss = dismiss;\nfunction replace(url) {\n  return this.linkTo((0, href_1.resolveHref)(url), 'REPLACE');\n}\nexports.replace = replace;\nfunction dismissAll() {\n  var _this$navigationRef2;\n  (_this$navigationRef2 = this.navigationRef) == null ? void 0 : _this$navigationRef2.dispatch(native_1.StackActions.popToTop());\n}\nexports.dismissAll = dismissAll;\nfunction goBack() {\n  var _this$navigationRef3, _this$navigationRef3$;\n  assertIsReady(this);\n  (_this$navigationRef3 = this.navigationRef) == null ? void 0 : (_this$navigationRef3$ = _this$navigationRef3.current) == null ? void 0 : _this$navigationRef3$.goBack();\n}\nexports.goBack = goBack;\nfunction canGoBack() {\n  var _this$navigationRef$c, _this$navigationRef4, _this$navigationRef4$;\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return (_this$navigationRef$c = (_this$navigationRef4 = this.navigationRef) == null ? void 0 : (_this$navigationRef4$ = _this$navigationRef4.current) == null ? void 0 : _this$navigationRef4$.canGoBack()) != null ? _this$navigationRef$c : false;\n}\nexports.canGoBack = canGoBack;\nfunction canDismiss() {\n  var state = this.rootState;\n  while (state) {\n    var _state$routes, _state$routes$state$i;\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n    state = (_state$routes = state.routes) == null ? void 0 : (_state$routes$state$i = _state$routes[state.index]) == null ? void 0 : _state$routes$state$i.state;\n  }\n  return false;\n}\nexports.canDismiss = canDismiss;\nfunction setParams() {\n  var _this$navigationRef5, _this$navigationRef5$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assertIsReady(this);\n  return ((_this$navigationRef5 = this.navigationRef) == null ? void 0 : (_this$navigationRef5$ = _this$navigationRef5.current) == null ? void 0 : _this$navigationRef5$.setParams.bind(_this$navigationRef5$))(params);\n}\nexports.setParams = setParams;\nfunction linkTo(href, event) {\n  var _this = this;\n  if ((0, url_1.shouldLinkExternally)(href)) {\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n  var rootState = navigationRef.getRootState();\n  if (href.startsWith('.')) {\n    var _this$routeInfo$segme, _this$routeInfo, _this$routeInfo$segme2, _this$routeInfo4;\n    var base = (_this$routeInfo$segme = (_this$routeInfo = this.routeInfo) == null ? void 0 : (_this$routeInfo$segme2 = _this$routeInfo.segments) == null ? void 0 : _this$routeInfo$segme2.map(function (segment) {\n      if (!segment.startsWith('[')) return segment;\n      if (segment.startsWith('[...')) {\n        var _this$routeInfo2, _this$routeInfo2$para;\n        segment = segment.slice(4, -1);\n        var params = (_this$routeInfo2 = _this.routeInfo) == null ? void 0 : (_this$routeInfo2$para = _this$routeInfo2.params) == null ? void 0 : _this$routeInfo2$para[segment];\n        if (Array.isArray(params)) {\n          return params.join('/');\n        } else {\n          var _params$split$join, _params$split;\n          return (_params$split$join = params == null ? void 0 : (_params$split = params.split(',')) == null ? void 0 : _params$split.join('/')) != null ? _params$split$join : '';\n        }\n      } else {\n        var _this$routeInfo3, _this$routeInfo3$para;\n        segment = segment.slice(1, -1);\n        return (_this$routeInfo3 = _this.routeInfo) == null ? void 0 : (_this$routeInfo3$para = _this$routeInfo3.params) == null ? void 0 : _this$routeInfo3$para[segment];\n      }\n    }).filter(Boolean).join('/')) != null ? _this$routeInfo$segme : '/';\n    if (!((_this$routeInfo4 = this.routeInfo) != null && _this$routeInfo4.isIndex)) {\n      base += '/..';\n    }\n    href = (0, path_1.resolve)(base, href);\n  }\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n  return navigationRef.dispatch(getNavigateAction(state, rootState, event));\n}\nexports.linkTo = linkTo;\nfunction rewriteNavigationStateToParams(state) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!state) return params;\n  var lastRoute = state.routes[state.routes.length - 1];\n  params.screen = lastRoute.name;\n  params.params = lastRoute.params ? JSON.parse(JSON.stringify(lastRoute.params)) : {};\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n  return JSON.parse(JSON.stringify(params));\n}\nfunction getNavigateAction(state, parentState) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'NAVIGATE';\n  var route = state.routes[state.routes.length - 1];\n  var currentRoute = parentState.routes.find(function (parentRoute) {\n    return parentRoute.name === route.name;\n  });\n  var routesAreEqual = parentState.routes[parentState.index] === currentRoute;\n  if (route.state && routesAreEqual && currentRoute.state) {\n    return getNavigateAction(route.state, currentRoute.state, type);\n  }\n  var _rewriteNavigationSta = rewriteNavigationStateToParams(state),\n    screen = _rewriteNavigationSta.screen,\n    params = _rewriteNavigationSta.params;\n  if (type === 'PUSH' && parentState.type !== 'stack') {\n    type = 'NAVIGATE';\n  } else if (type === 'REPLACE' && parentState.type === 'tab') {\n    type = 'JUMP_TO';\n  }\n  return {\n    type: type,\n    target: parentState.key,\n    payload: {\n      name: screen,\n      params: params\n    }\n  };\n}","map":{"version":3,"names":["native_1","require","Linking","__importStar","href_1","path_1","url_1","assertIsReady","store","navigationRef","isReady","Error","navigate","url","linkTo","resolveHref","exports","push","dismiss","count","_this$navigationRef","dispatch","StackActions","pop","replace","dismissAll","_this$navigationRef2","popToTop","goBack","_this$navigationRef3","_this$navigationRef3$","current","canGoBack","_this$navigationRef$c","_this$navigationRef4","_this$navigationRef4$","canDismiss","state","rootState","_state$routes","_state$routes$state$i","type","routes","length","index","undefined","setParams","_this$navigationRef5","_this$navigationRef5$","params","arguments","bind","href","event","_this","shouldLinkExternally","openURL","linking","getRootState","startsWith","_this$routeInfo$segme","_this$routeInfo","_this$routeInfo$segme2","_this$routeInfo4","base","routeInfo","segments","map","segment","_this$routeInfo2","_this$routeInfo2$para","slice","Array","isArray","join","_params$split$join","_params$split","split","_this$routeInfo3","_this$routeInfo3$para","filter","Boolean","isIndex","resolve","getStateFromPath","config","console","error","getNavigateAction","rewriteNavigationStateToParams","lastRoute","screen","name","JSON","parse","stringify","parentState","route","currentRoute","find","parentRoute","routesAreEqual","_rewriteNavigationSta","target","key","payload"],"sources":["/Users/josh/src/ui/apps/old-demo/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import { StackActions, type NavigationState } from '@react-navigation/native';\nimport * as Linking from 'expo-linking';\n\nimport type { RouterStore } from './router-store';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { Href, resolveHref } from '../link/href';\nimport { resolve } from '../link/path';\nimport { shouldLinkExternally } from '../utils/url';\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport function navigate(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'NAVIGATE');\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'PUSH');\n}\n\nexport function dismiss(this: RouterStore, count?: number) {\n  this.navigationRef?.dispatch(StackActions.pop(count));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'REPLACE');\n}\n\nexport function dismissAll(this: RouterStore) {\n  this.navigationRef?.dispatch(StackActions.popToTop());\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function canDismiss(this: RouterStore): boolean {\n  let state = this.rootState;\n\n  // Keep traversing down the state tree until we find a stack navigator that we can pop\n  while (state) {\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n\n    state = state.routes?.[state.index]?.state as any;\n  }\n\n  return false;\n}\n\nexport function setParams(this: RouterStore, params: Record<string, string | number> = {}) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (shouldLinkExternally(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  if (href.startsWith('.')) {\n    // Resolve base path by merging the current segments with the params\n    let base =\n      this.routeInfo?.segments\n        ?.map((segment) => {\n          if (!segment.startsWith('[')) return segment;\n\n          if (segment.startsWith('[...')) {\n            segment = segment.slice(4, -1);\n            const params = this.routeInfo?.params?.[segment];\n            if (Array.isArray(params)) {\n              return params.join('/');\n            } else {\n              return params?.split(',')?.join('/') ?? '';\n            }\n          } else {\n            segment = segment.slice(1, -1);\n            return this.routeInfo?.params?.[segment];\n          }\n        })\n        .filter(Boolean)\n        .join('/') ?? '/';\n\n    if (!this.routeInfo?.isIndex) {\n      base += '/..';\n    }\n\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  return navigationRef.dispatch(getNavigateAction(state, rootState, event));\n}\n\ntype NavigationParams = Partial<{\n  screen: string;\n  params: NavigationParams;\n}>;\n\nfunction rewriteNavigationStateToParams(\n  state?: { routes: ResultState['routes'] } | NavigationState,\n  params: NavigationParams = {}\n) {\n  if (!state) return params;\n  // We Should always have at least one route in the state\n  const lastRoute = state.routes[state.routes.length - 1]!;\n  params.screen = lastRoute.name;\n  // Weirdly, this always needs to be an object. If it's undefined, it won't work.\n  params.params = lastRoute.params ? JSON.parse(JSON.stringify(lastRoute.params)) : {};\n\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n\n  return JSON.parse(JSON.stringify(params));\n}\n\nfunction getNavigateAction(state: ResultState, parentState: NavigationState, type = 'NAVIGATE') {\n  const route = state.routes[state.routes.length - 1]!;\n\n  const currentRoute = parentState.routes.find((parentRoute) => parentRoute.name === route.name);\n  const routesAreEqual = parentState.routes[parentState.index] === currentRoute;\n\n  // If there is nested state and the routes are equal, we should keep going down the tree\n  if (route.state && routesAreEqual && currentRoute.state) {\n    return getNavigateAction(route.state, currentRoute.state as any, type);\n  }\n\n  // Either we reached the bottom of the state or the point where the routes diverged\n  const { screen, params } = rewriteNavigationStateToParams(state);\n\n  if (type === 'PUSH' && parentState.type !== 'stack') {\n    type = 'NAVIGATE';\n  } else if (type === 'REPLACE' && parentState.type === 'tab') {\n    type = 'JUMP_TO';\n  }\n\n  return {\n    type,\n    target: parentState.key,\n    payload: {\n      name: screen,\n      params,\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}