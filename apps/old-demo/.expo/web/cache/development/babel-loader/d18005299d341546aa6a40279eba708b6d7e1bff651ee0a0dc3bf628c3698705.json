{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stripBaseUrl = exports.getMatchableRouteConfigs = exports.getUrlWithReactNavigationConcessions = void 0;\nvar escape_string_regexp_1 = __importDefault(require(\"escape-string-regexp\"));\nvar findFocusedRoute_1 = require(\"./findFocusedRoute\");\nvar validatePathConfig_1 = __importDefault(require(\"./validatePathConfig\"));\nvar matchers_1 = require(\"../matchers\");\nfunction getUrlWithReactNavigationConcessions(path) {\n  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var parsed;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch (_unused) {\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: ''\n    };\n  }\n  var pathname = parsed.pathname;\n  return {\n    nonstandardPathname: stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    inputPathnameWithoutHash: stripBaseUrl(path, baseUrl).replace(/#.*$/, '')\n  };\n}\nexports.getUrlWithReactNavigationConcessions = getUrlWithReactNavigationConcessions;\nfunction getStateFromPath(path, options) {\n  var _getMatchableRouteCon = getMatchableRouteConfigs(options),\n    initialRoutes = _getMatchableRouteCon.initialRoutes,\n    configs = _getMatchableRouteCon.configs;\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\nexports.default = getStateFromPath;\nfunction getMatchableRouteConfigs(options) {\n  if (options) {\n    (0, validatePathConfig_1.default)(options);\n  }\n  var screens = options == null ? void 0 : options.screens;\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n  var initialRoutes = [];\n  if (options != null && options.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: []\n    });\n  }\n  var converted = Object.keys(screens).map(function (key) {\n    return createNormalizedConfigs(key, screens, [], initialRoutes);\n  }).flat();\n  var resolvedInitialPatterns = initialRoutes.map(function (route) {\n    return joinPaths.apply(void 0, _toConsumableArray(route.parentScreens).concat([route.initialRouteName]));\n  });\n  var convertedWithInitial = converted.map(function (config) {\n    return _objectSpread(_objectSpread({}, config), {}, {\n      isInitial: resolvedInitialPatterns.includes(config.routeNames.join('/'))\n    });\n  });\n  var configs = convertedWithInitial.sort(sortConfigs);\n  assertConfigDuplicates(configs);\n  return {\n    configs: configs,\n    initialRoutes: initialRoutes\n  };\n}\nexports.getMatchableRouteConfigs = getMatchableRouteConfigs;\nfunction assertConfigDuplicates(configs) {\n  configs.reduce(function (acc, config) {\n    var _config$regex$toStrin, _config$regex;\n    var indexedKey = (_config$regex$toStrin = (_config$regex = config.regex) == null ? void 0 : _config$regex.toString()) != null ? _config$regex$toStrin : config.pattern;\n    var alpha = acc[indexedKey];\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      var a = alpha.routeNames;\n      var b = config.routeNames;\n      var intersects = a.length > b.length ? b.every(function (it, i) {\n        return a[i] === it;\n      }) : a.every(function (it, i) {\n        return b[i] === it;\n      });\n      if (!intersects) {\n        var last = config.pattern.split('/').pop();\n        if (!(last != null && last.match(/^\\*not-found$/))) {\n          var routeType = last != null && last.startsWith(':') ? 'dynamic route' : last != null && last.startsWith('*') ? 'dynamic-rest route' : 'route';\n          throw new Error(`The ${routeType} pattern '${config.pattern || '/'}' resolves to both '${alpha.userReadableName}' and '${config.userReadableName}'. Patterns must be unique and cannot resolve to more than one route.`);\n        }\n      }\n    }\n    return Object.assign(acc, _defineProperty({}, indexedKey, config));\n  }, {});\n}\nfunction sortConfigs(a, b) {\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  }\n  if (a.pattern.startsWith(b.pattern) && b.screen !== 'index') {\n    return -1;\n  }\n  if (b.pattern.startsWith(a.pattern) && a.screen !== 'index') {\n    return 1;\n  }\n  var aParts = a.pattern.split('/').filter(function (part) {\n    return (0, matchers_1.matchGroupName)(part) == null;\n  });\n  if (a.screen === 'index') {\n    aParts.push('index');\n  }\n  var bParts = b.pattern.split('/').filter(function (part) {\n    return (0, matchers_1.matchGroupName)(part) == null;\n  });\n  if (b.screen === 'index') {\n    bParts.push('index');\n  }\n  for (var i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    if (aParts[i] == null) {\n      return 1;\n    }\n    if (bParts[i] == null) {\n      return -1;\n    }\n    var aWildCard = aParts[i].startsWith('*');\n    var bWildCard = bParts[i].startsWith('*');\n    if (aWildCard && bWildCard) {\n      var aNotFound = aParts[i].match(/^[*]not-found$/);\n      var bNotFound = bParts[i].match(/^[*]not-found$/);\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    if (aWildCard) {\n      return 1;\n    }\n    if (bWildCard) {\n      return -1;\n    }\n    var aSlug = aParts[i].startsWith(':');\n    var bSlug = bParts[i].startsWith(':');\n    if (aSlug && bSlug) {\n      var _aNotFound = aParts[i].match(/^[*]not-found$/);\n      var _bNotFound = bParts[i].match(/^[*]not-found$/);\n      if (_aNotFound && _bNotFound) {\n        continue;\n      } else if (_aNotFound) {\n        return 1;\n      } else if (_bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    if (aSlug) {\n      return 1;\n    }\n    if (bSlug) {\n      return -1;\n    }\n  }\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n  return bParts.length - aParts.length;\n}\nfunction getStateFromEmptyPathWithConfigs(path, configs, initialRoutes) {\n  var _ref, _leafNodes$find;\n  var leafNodes = configs.filter(function (config) {\n    return !config.hasChildren;\n  }).map(function (value) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      path: (0, matchers_1.stripGroupSegmentsFromPath)(value.path)\n    });\n  });\n  var match = (_ref = (_leafNodes$find = leafNodes.find(function (config) {\n    return config.path === '' && (!config.regex || config.regex.test(''));\n  })) != null ? _leafNodes$find : leafNodes.find(function (config) {\n    return config.path.startsWith(':') && config.regex.test('');\n  })) != null ? _ref : leafNodes.find(function (config) {\n    return config.path.startsWith('*') && config.regex.test('/');\n  });\n  if (!match) {\n    return undefined;\n  }\n  var routes = match.routeNames.map(function (name) {\n    if (!match._route) {\n      return {\n        name: name\n      };\n    }\n    return {\n      name: name,\n      _route: match._route\n    };\n  });\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\nfunction getStateFromPathWithConfigs(path, configs, initialRoutes) {\n  var formattedPaths = getUrlWithReactNavigationConcessions(path);\n  if (formattedPaths.nonstandardPathname === '/') {\n    return getStateFromEmptyPathWithConfigs(formattedPaths.inputPathnameWithoutHash, configs, initialRoutes);\n  }\n  var routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n  if (routes == null) {\n    return undefined;\n  }\n  return createNestedStateObject(formattedPaths.inputPathnameWithoutHash, routes, configs, initialRoutes);\n}\nvar joinPaths = function joinPaths() {\n  var _ref2;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\nfunction matchAgainstConfigs(remaining, configs) {\n  var routes;\n  var remainingPath = remaining;\n  var _loop = function _loop(config) {\n      var _config$pattern;\n      if (!config.regex) {\n        return 0;\n      }\n      var match = remainingPath.match(config.regex);\n      if (!match) {\n        return 0;\n      }\n      var matchedParams = (_config$pattern = config.pattern) == null ? void 0 : _config$pattern.split('/').filter(function (p) {\n        return p.match(/^[:*]/);\n      }).reduce(function (acc, p, i) {\n        var _match;\n        if (p.match(/^\\*/)) {\n          return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, p, match[(i + 1) * 2]));\n        }\n        return Object.assign(acc, _defineProperty({}, p, (_match = match[(i + 1) * 2]) == null ? void 0 : _match.replace(/\\//, '')));\n      }, {});\n      var routeFromName = function routeFromName(name) {\n        var config = configs.find(function (c) {\n          return c.screen === name;\n        });\n        if (!(config != null && config.path)) {\n          return {\n            name: name\n          };\n        }\n        var segments = config.path.split('/');\n        var params = {};\n        segments.filter(function (p) {\n          return p.match(/^[:*]/);\n        }).forEach(function (p) {\n          var value = matchedParams[p];\n          if (value) {\n            var _config$parse;\n            if (p.match(/^\\*/)) {\n              var _value;\n              value = (_value = value) == null ? void 0 : _value.split('/').filter(Boolean);\n            }\n            var key = p.replace(/^[:*]/, '').replace(/\\?$/, '');\n            params[key] = (_config$parse = config.parse) != null && _config$parse[key] ? config.parse[key](value) : value;\n          }\n        });\n        if (params && Object.keys(params).length) {\n          return {\n            name: name,\n            params: params\n          };\n        }\n        return {\n          name: name\n        };\n      };\n      routes = config.routeNames.map(function (name) {\n        if (!config._route) {\n          return _objectSpread({}, routeFromName(name));\n        }\n        return _objectSpread(_objectSpread({}, routeFromName(name)), {}, {\n          _route: config._route\n        });\n      });\n      var combinedParams = routes.reduce(function (acc, r) {\n        return Object.assign(acc, r.params);\n      }, {});\n      var hasCombinedParams = Object.keys(combinedParams).length > 0;\n      routes = routes.map(function (r) {\n        if (hasCombinedParams) {\n          r.params = combinedParams;\n        }\n        return r;\n      });\n      remainingPath = remainingPath.replace(match[1], '');\n      return 1;\n    },\n    _ret;\n  for (var config of configs) {\n    _ret = _loop(config);\n    if (_ret === 0) continue;\n    if (_ret === 1) break;\n  }\n  return routes;\n}\nfunction equalHeritage(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\nvar createNormalizedConfigs = function createNormalizedConfigs(screen, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var parentScreens = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var parentPattern = arguments.length > 5 ? arguments[5] : undefined;\n  var configs = [];\n  routeNames.push(screen);\n  parentScreens.push(screen);\n  var config = routeConfig[screen];\n  if (typeof config === 'string') {\n    var pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === 'object') {\n    var _pattern;\n    var _route = config._route;\n    if (typeof config.path === 'string') {\n      var _Object$keys;\n      if (config.exact && config.path === undefined) {\n        throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n      }\n      _pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n      configs.push(createConfigItem(screen, routeNames, _pattern, config.path, config.screens ? !!((_Object$keys = Object.keys(config.screens)) != null && _Object$keys.length) : false, config.parse, _route));\n    }\n    if (config.screens) {\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens: parentScreens\n        });\n      }\n      Object.keys(config.screens).forEach(function (nestedConfig) {\n        var _pattern2;\n        var result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, _toConsumableArray(parentScreens), (_pattern2 = _pattern) != null ? _pattern2 : parentPattern);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n  routeNames.pop();\n  return configs;\n};\nfunction formatRegexPattern(it) {\n  it = it.replace(' ', '%20');\n  if (it.startsWith(':')) {\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n  if ((0, matchers_1.matchGroupName)(it) != null) {\n    return `(?:${(0, escape_string_regexp_1.default)(it)}\\\\/)?`;\n  }\n  return (0, escape_string_regexp_1.default)(it) + `\\\\/`;\n}\nvar createConfigItem = function createConfigItem(screen, routeNames, pattern, path, hasChildren, parse, _route) {\n  pattern = pattern.split('/').filter(Boolean).join('/');\n  var regex = pattern ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`) : undefined;\n  return {\n    screen: screen,\n    regex: regex,\n    pattern: pattern,\n    path: path,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse,\n    userReadableName: [].concat(_toConsumableArray(routeNames.slice(0, -1)), [path || screen]).join('/'),\n    hasChildren: !!hasChildren,\n    _route: _route\n  };\n};\nvar findParseConfigForRoute = function findParseConfigForRoute(routeName, routeConfigs) {\n  for (var config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n};\nvar findInitialRoute = function findInitialRoute(routeName, parentScreens, initialRoutes) {\n  for (var config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\nvar createStateObject = function createStateObject(initialRoute, route, isEmpty) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, route]\n      };\n    }\n    return {\n      routes: [route]\n    };\n  }\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{\n        name: initialRoute\n      }, _objectSpread(_objectSpread({}, route), {}, {\n        state: {\n          routes: []\n        }\n      })]\n    };\n  }\n  return {\n    routes: [_objectSpread(_objectSpread({}, route), {}, {\n      state: {\n        routes: []\n      }\n    })]\n  };\n};\nvar createNestedStateObject = function createNestedStateObject(path, routes, routeConfigs, initialRoutes) {\n  var route = routes.shift();\n  var parentScreens = [];\n  var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n  parentScreens.push(route.name);\n  var state = createStateObject(initialRoute, route, routes.length === 0);\n  if (routes.length > 0) {\n    var nestedState = state;\n    while (route = routes.shift()) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n      var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state;\n      }\n      parentScreens.push(route.name);\n    }\n  }\n  route = (0, findFocusedRoute_1.findFocusedRoute)(state);\n  route.path = (0, matchers_1.stripGroupSegmentsFromPath)(path);\n  var params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params);\n    for (var _ref3 of Object.entries(params)) {\n      var _route$params, _route$params2;\n      var _ref4 = _slicedToArray(_ref3, 2);\n      var name = _ref4[0];\n      var value = _ref4[1];\n      if ((_route$params = route.params) != null && _route$params[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n        }\n      }\n      if (!((_route$params2 = route.params) != null && _route$params2[name])) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n  return state;\n};\nvar parseQueryParams = function parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var searchParams = new URLSearchParams(query);\n  var params = Object.fromEntries(searchParams);\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n  return Object.keys(params).length ? params : undefined;\n};\nvar baseUrlCache = new Map();\nfunction getBaseUrlRegex(baseUrl) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl);\n  }\n  var regex = new RegExp(`^\\\\/?${(0, escape_string_regexp_1.default)(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\nfunction stripBaseUrl(path) {\n  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      var reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\nexports.stripBaseUrl = stripBaseUrl;","map":{"version":3,"names":["escape_string_regexp_1","__importDefault","require","findFocusedRoute_1","validatePathConfig_1","matchers_1","getUrlWithReactNavigationConcessions","path","baseUrl","arguments","length","undefined","parsed","URL","_unused","nonstandardPathname","inputPathnameWithoutHash","pathname","stripBaseUrl","replace","exports","getStateFromPath","options","_getMatchableRouteCon","getMatchableRouteConfigs","initialRoutes","configs","getStateFromPathWithConfigs","default","screens","Error","initialRouteName","push","parentScreens","converted","Object","keys","map","key","createNormalizedConfigs","flat","resolvedInitialPatterns","route","joinPaths","apply","_toConsumableArray","concat","convertedWithInitial","config","_objectSpread","isInitial","includes","routeNames","join","sort","sortConfigs","assertConfigDuplicates","reduce","acc","_config$regex$toStrin","_config$regex","indexedKey","regex","toString","pattern","alpha","hasChildren","a","b","intersects","every","it","i","last","split","pop","match","routeType","startsWith","userReadableName","assign","_defineProperty","localeCompare","screen","aParts","filter","part","matchGroupName","bParts","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","getStateFromEmptyPathWithConfigs","_ref","_leafNodes$find","leafNodes","value","stripGroupSegmentsFromPath","find","test","routes","name","_route","createNestedStateObject","formattedPaths","matchAgainstConfigs","_ref2","_len","paths","Array","_key","p","Boolean","remaining","remainingPath","_loop","_config$pattern","matchedParams","_match","routeFromName","c","segments","params","forEach","_config$parse","_value","parse","combinedParams","r","hasCombinedParams","_ret","equalHeritage","routeConfig","initials","parentPattern","createConfigItem","_Object$keys","exact","nestedConfig","_pattern2","result","formatRegexPattern","endsWith","RegExp","slice","findParseConfigForRoute","routeName","routeConfigs","findInitialRoute","createStateObject","initialRoute","isEmpty","index","state","shift","nestedState","nestedStateIndex","findFocusedRoute","parseQueryParams","create","_ref3","entries","_route$params","_route$params2","_ref4","_slicedToArray","process","env","NODE_ENV","console","warn","parseConfig","query","searchParams","URLSearchParams","fromEntries","hasOwnProperty","call","baseUrlCache","Map","getBaseUrlRegex","has","get","set","reg"],"sources":["/Users/josh/src/ui/apps/old-demo/node_modules/expo-router/src/fork/getStateFromPath.ts"],"sourcesContent":["import { PathConfigMap } from '@react-navigation/core';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport validatePathConfig from './validatePathConfig';\nimport { RouteNode } from '../Route';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n  hasChildren: boolean;\n  userReadableName: string;\n  _route?: RouteNode;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: '',\n    };\n  }\n\n  const pathname = parsed.pathname;\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    nonstandardPathname:\n      stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n\n    // React Navigation doesn't support hashes, so here\n    inputPathnameWithoutHash: stripBaseUrl(path, baseUrl).replace(/#.*$/, ''),\n  };\n}\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getMatchableRouteConfigs(options);\n\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\n\nexport function getMatchableRouteConfigs<ParamList extends object>(options?: Options<ParamList>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const screens = options?.screens;\n  // Expo Router disallows usage without a linking config.\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n\n  // This will be mutated...\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  // Create a normalized configs array which will be easier to use.\n  const converted = Object.keys(screens)\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\n    .flat();\n\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  const convertedWithInitial = converted.map((config) => ({\n    ...config,\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join('/')),\n  }));\n\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\n  const configs = convertedWithInitial.sort(sortConfigs);\n\n  // Assert any duplicates before we start parsing.\n  assertConfigDuplicates(configs);\n\n  return { configs, initialRoutes };\n}\n\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\n    const indexedKey = config.regex?.toString() ?? config.pattern;\n    const alpha = acc[indexedKey];\n    // NOTE(EvanBacon): Skips checking nodes that have children.\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      const a = alpha.routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\n        // file-based routing.\n        const last = config.pattern.split('/').pop();\n\n        if (!last?.match(/^\\*not-found$/)) {\n          const routeType = last?.startsWith(':')\n            ? 'dynamic route'\n            : last?.startsWith('*')\n            ? 'dynamic-rest route'\n            : 'route';\n          throw new Error(\n            `The ${routeType} pattern '${config.pattern || '/'}' resolves to both '${\n              alpha.userReadableName\n            }' and '${\n              config.userReadableName\n            }'. Patterns must be unique and cannot resolve to more than one route.`\n          );\n        }\n      }\n    }\n\n    return Object.assign(acc, {\n      [indexedKey]: config,\n    });\n  }, {});\n}\n\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\n  // Sort config so that:\n  // - the most exhaustive ones are always at the beginning\n  // - patterns with wildcard are always at the end\n\n  // If 2 patterns are same, move the one with less route names up\n  // This is an error state, so it's only useful for consistent error messages\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  }\n\n  // If one of the patterns starts with the other, it's more exhaustive\n  // So move it up\n  if (\n    a.pattern.startsWith(b.pattern) &&\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\n    b.screen !== 'index'\n  ) {\n    return -1;\n  }\n\n  if (b.pattern.startsWith(a.pattern) && a.screen !== 'index') {\n    return 1;\n  }\n\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\n  // as a slug or wildcard when nested more than one level deep.\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\n  const aParts = a.pattern\n    .split('/')\n    // Strip out group names to ensure they don't affect the priority.\n    .filter((part) => matchGroupName(part) == null);\n  if (a.screen === 'index') {\n    aParts.push('index');\n  }\n\n  const bParts = b.pattern.split('/').filter((part) => matchGroupName(part) == null);\n  if (b.screen === 'index') {\n    bParts.push('index');\n  }\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    // if b is longer, b get higher priority\n    if (aParts[i] == null) {\n      return 1;\n    }\n    // if a is longer, a get higher priority\n    if (bParts[i] == null) {\n      return -1;\n    }\n\n    const aWildCard = aParts[i].startsWith('*');\n    const bWildCard = bParts[i].startsWith('*');\n    // if both are wildcard we compare next component\n    if (aWildCard && bWildCard) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aWildCard) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bWildCard) {\n      return -1;\n    }\n\n    const aSlug = aParts[i].startsWith(':');\n    const bSlug = bParts[i].startsWith(':');\n    // if both are wildcard we compare next component\n    if (aSlug && bSlug) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aSlug) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bSlug) {\n      return -1;\n    }\n  }\n\n  // Sort initial routes with a higher priority than routes which will push more screens\n  // this ensures shared routes go to the shortest path.\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n\n  return bParts.length - aParts.length;\n}\n\nfunction getStateFromEmptyPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  if (!match) {\n    return undefined;\n  }\n\n  const routes = match.routeNames.map((name) => {\n    if (!match._route) {\n      return { name };\n    }\n    return {\n      name,\n      _route: match._route,\n    };\n  });\n\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\n\nfunction getStateFromPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  const formattedPaths = getUrlWithReactNavigationConcessions(path);\n\n  if (formattedPaths.nonstandardPathname === '/') {\n    return getStateFromEmptyPathWithConfigs(\n      formattedPaths.inputPathnameWithoutHash,\n      configs,\n      initialRoutes\n    );\n  }\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n\n  if (routes == null) {\n    return undefined;\n  }\n  // This will always be empty if full path matched\n  return createNestedStateObject(\n    formattedPaths.inputPathnameWithoutHash,\n    routes,\n    configs,\n    initialRoutes\n  );\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nfunction matchAgainstConfigs(remaining: string, configs: RouteConfig[]): ParsedRoute[] | undefined {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (!match) {\n      continue;\n    }\n\n    // TODO: Add support for wildcard routes\n    const matchedParams = config.pattern\n      ?.split('/')\n      .filter((p) => p.match(/^[:*]/))\n      .reduce<Record<string, any>>((acc, p, i) => {\n        if (p.match(/^\\*/)) {\n          return {\n            ...acc,\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\n          };\n        }\n        return Object.assign(acc, {\n          // The param segments appear every second item starting from 2 in the regex match result.\n          // This will only work if we ensure groups aren't included in the match.\n          [p]: match![(i + 1) * 2]?.replace(/\\//, ''),\n        });\n      }, {});\n\n    const routeFromName = (name: string) => {\n      const config = configs.find((c) => c.screen === name);\n      if (!config?.path) {\n        return { name };\n      }\n\n      const segments = config.path.split('/');\n\n      const params: Record<string, any> = {};\n\n      segments\n        .filter((p) => p.match(/^[:*]/))\n        .forEach((p) => {\n          let value = matchedParams[p];\n          if (value) {\n            if (p.match(/^\\*/)) {\n              // Convert to an array before providing as a route.\n              value = value?.split('/').filter(Boolean);\n            }\n\n            const key = p.replace(/^[:*]/, '').replace(/\\?$/, '');\n            params[key] = config.parse?.[key] ? config.parse[key](value) : value;\n          }\n        });\n\n      if (params && Object.keys(params).length) {\n        return { name, params };\n      }\n\n      return { name };\n    };\n\n    routes = config.routeNames.map((name) => {\n      if (!config._route) {\n        return { ...routeFromName(name) };\n      }\n      return {\n        ...routeFromName(name),\n        _route: config._route,\n      };\n    });\n\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\n    const combinedParams = routes.reduce<Record<string, any>>(\n      (acc, r) => Object.assign(acc, r.params),\n      {}\n    );\n\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\n\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n    routes = routes.map((r) => {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n\n    remainingPath = remainingPath.replace(match[1], '');\n\n    break;\n  }\n\n  return routes;\n}\n\nfunction equalHeritage(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[] = [],\n  parentScreens: string[] = [],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = (routeConfig as any)[screen];\n\n  if (typeof config === 'string') {\n    // TODO: This should never happen with the addition of `_route`\n\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    const { _route } = config;\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config.parse,\n          _route\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  hasChildren?: boolean,\n  parse?: ParseConfig,\n  _route?: any\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join('/'),\n    hasChildren: !!hasChildren,\n    _route,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  routeConfigs: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      // If the parents are the same but the route name doesn't match the initial route\n      // then we return the initial route.\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    }\n    return {\n      routes: [route],\n    };\n  }\n\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n    };\n  }\n  return {\n    routes: [{ ...route, state: { routes: [] } }],\n  };\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  routeConfigs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n\n  // Remove groups from the path while preserving a trailing slash.\n  route.path = stripGroupSegmentsFromPath(path);\n\n  const params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {\n  const query = path.split('?')[1];\n  const searchParams = new URLSearchParams(query);\n  const params = Object.fromEntries(\n    // @ts-ignore: [Symbol.iterator] is indeed, available on every platform.\n    searchParams\n  );\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n\nconst baseUrlCache = new Map<string, RegExp>();\n\nfunction getBaseUrlRegex(baseUrl: string) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl)!;\n  }\n  const regex = new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      const reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAEA,IAAAA,sBAAA,GAAAC,eAAA,CAAAC,OAAA;AAEA,IAAAC,kBAAA,GAAAD,OAAA;AACA,IAAAE,oBAAA,GAAAH,eAAA,CAAAC,OAAA;AAEA,IAAAG,UAAA,GAAAH,OAAA;AAqCA,SAAgBI,oCAAoCA,CAClDC,IAAY,EAC2C;EAAA,IAAvDC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;EAEA,IAAIG,MAAW;EACf,IAAI;IACFA,MAAM,GAAG,IAAIC,GAAG,CAACN,IAAI,EAAE,uBAAuB,CAAC;GAChD,CAAC,OAAAO,OAAA,EAAM;IAEN,OAAO;MACLC,mBAAmB,EAAE,EAAE;MACvBC,wBAAwB,EAAE;KAC3B;;EAGH,IAAMC,QAAQ,GAAGL,MAAM,CAACK,QAAQ;EAGhC,OAAO;IAELF,mBAAmB,EACjBG,YAAY,CAACD,QAAQ,EAAET,OAAO,CAAC,CAACW,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG;IAGjFH,wBAAwB,EAAEE,YAAY,CAACX,IAAI,EAAEC,OAAO,CAAC,CAACW,OAAO,CAAC,MAAM,EAAE,EAAE;GACzE;AACH;AA1BAC,OAAA,CAAAd,oCAAA,GAAAA,oCAAA;AAiDA,SAAwBe,gBAAgBA,CACtCd,IAAY,EACZe,OAA4B;EAE5B,IAAAC,qBAAA,GAAmCC,wBAAwB,CAACF,OAAO,CAAC;IAA5DG,aAAa,GAAAF,qBAAA,CAAbE,aAAa;IAAEC,OAAO,GAAAH,qBAAA,CAAPG,OAAO;EAE9B,OAAOC,2BAA2B,CAACpB,IAAI,EAAEmB,OAAO,EAAED,aAAa,CAAC;AAClE;AAPAL,OAAA,CAAAQ,OAAA,GAAAP,gBAAA;AASA,SAAgBG,wBAAwBA,CAA2BF,OAA4B;EAC7F,IAAIA,OAAO,EAAE;IACX,IAAAlB,oBAAA,CAAAwB,OAAkB,EAACN,OAAO,CAAC;;EAG7B,IAAMO,OAAO,GAAGP,OAAO,oBAAPA,OAAO,CAAEO,OAAO;EAEhC,IAAI,CAACA,OAAO,EAAE;IACZ,MAAMC,KAAK,CAAC,4EAA4E,CAAC;;EAI3F,IAAML,aAAa,GAAyB,EAAE;EAE9C,IAAIH,OAAO,YAAPA,OAAO,CAAES,gBAAgB,EAAE;IAC7BN,aAAa,CAACO,IAAI,CAAC;MACjBD,gBAAgB,EAAET,OAAO,CAACS,gBAAgB;MAC1CE,aAAa,EAAE;KAChB,CAAC;;EAIJ,IAAMC,SAAS,GAAGC,MAAM,CAACC,IAAI,CAACP,OAAO,CAAC,CACnCQ,GAAG,CAAC,UAACC,GAAG;IAAA,OAAKC,uBAAuB,CAACD,GAAG,EAAET,OAAO,EAAE,EAAE,EAAEJ,aAAa,CAAC;EAAA,EAAC,CACtEe,IAAI,EAAE;EAET,IAAMC,uBAAuB,GAAGhB,aAAa,CAACY,GAAG,CAAC,UAACK,KAAK;IAAA,OACtDC,SAAS,CAAAC,KAAA,SAAAC,kBAAA,CAAIH,KAAK,CAACT,aAAa,EAAAa,MAAA,EAAEJ,KAAK,CAACX,gBAAgB,GAAC;EAAA,EAC1D;EAED,IAAMgB,oBAAoB,GAAGb,SAAS,CAACG,GAAG,CAAC,UAACW,MAAM;IAAA,OAAAC,aAAA,CAAAA,aAAA,KAC7CD,MAAM;MAGTE,SAAS,EAAET,uBAAuB,CAACU,QAAQ,CAACH,MAAM,CAACI,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC;IAAC;EAAA,CACxE,CAAC;EAGH,IAAM3B,OAAO,GAAGqB,oBAAoB,CAACO,IAAI,CAACC,WAAW,CAAC;EAGtDC,sBAAsB,CAAC9B,OAAO,CAAC;EAE/B,OAAO;IAAEA,OAAO,EAAPA,OAAO;IAAED,aAAa,EAAbA;EAAa,CAAE;AACnC;AA5CAL,OAAA,CAAAI,wBAAA,GAAAA,wBAAA;AA8CA,SAASgC,sBAAsBA,CAAC9B,OAAsB;EAEpDA,OAAO,CAAC+B,MAAM,CAA8B,UAACC,GAAG,EAAEV,MAAM,EAAI;IAAA,IAAAW,qBAAA,EAAAC,aAAA;IAE1D,IAAMC,UAAU,IAAAF,qBAAA,IAAAC,aAAA,GAAGZ,MAAM,CAACc,KAAK,qBAAZF,aAAA,CAAcG,QAAQ,EAAE,YAAAJ,qBAAA,GAAIX,MAAM,CAACgB,OAAO;IAC7D,IAAMC,KAAK,GAAGP,GAAG,CAACG,UAAU,CAAC;IAE7B,IAAII,KAAK,IAAI,CAACA,KAAK,CAACC,WAAW,IAAI,CAAClB,MAAM,CAACkB,WAAW,EAAE;MACtD,IAAMC,CAAC,GAAGF,KAAK,CAACb,UAAU;MAC1B,IAAMgB,CAAC,GAAGpB,MAAM,CAACI,UAAU;MAI3B,IAAMiB,UAAU,GACdF,CAAC,CAACzD,MAAM,GAAG0D,CAAC,CAAC1D,MAAM,GAAG0D,CAAC,CAACE,KAAK,CAAC,UAACC,EAAE,EAAEC,CAAC;QAAA,OAAKL,CAAC,CAACK,CAAC,CAAC,KAAKD,EAAE;MAAA,EAAC,GAAGJ,CAAC,CAACG,KAAK,CAAC,UAACC,EAAE,EAAEC,CAAC;QAAA,OAAKJ,CAAC,CAACI,CAAC,CAAC,KAAKD,EAAE;MAAA,EAAC;MAEzF,IAAI,CAACF,UAAU,EAAE;QAGf,IAAMI,IAAI,GAAGzB,MAAM,CAACgB,OAAO,CAACU,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAE;QAE5C,IAAI,EAACF,IAAI,YAAJA,IAAI,CAAEG,KAAK,CAAC,eAAe,CAAC,GAAE;UACjC,IAAMC,SAAS,GAAGJ,IAAI,YAAJA,IAAI,CAAEK,UAAU,CAAC,GAAG,CAAC,GACnC,eAAe,GACfL,IAAI,YAAJA,IAAI,CAAEK,UAAU,CAAC,GAAG,CAAC,GACrB,oBAAoB,GACpB,OAAO;UACX,MAAM,IAAIhD,KAAK,CACb,OAAO+C,SAAS,aAAa7B,MAAM,CAACgB,OAAO,IAAI,GAAG,uBAChDC,KAAK,CAACc,gBACR,UACE/B,MAAM,CAAC+B,gBACT,uEAAuE,CACxE;;;;IAKP,OAAO5C,MAAM,CAAC6C,MAAM,CAACtB,GAAG,EAAAuB,eAAA,KACrBpB,UAAU,EAAGb,MAAM,CACrB,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;AACR;AAEA,SAASO,WAAWA,CAACY,CAAc,EAAEC,CAAc;EAOjD,IAAID,CAAC,CAACH,OAAO,KAAKI,CAAC,CAACJ,OAAO,EAAE;IAC3B,OAAOI,CAAC,CAAChB,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC6B,aAAa,CAACf,CAAC,CAACf,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;;EAKrE,IACEc,CAAC,CAACH,OAAO,CAACc,UAAU,CAACV,CAAC,CAACJ,OAAO,CAAC,IAE/BI,CAAC,CAACe,MAAM,KAAK,OAAO,EACpB;IACA,OAAO,CAAC,CAAC;;EAGX,IAAIf,CAAC,CAACJ,OAAO,CAACc,UAAU,CAACX,CAAC,CAACH,OAAO,CAAC,IAAIG,CAAC,CAACgB,MAAM,KAAK,OAAO,EAAE;IAC3D,OAAO,CAAC;;EAMV,IAAMC,MAAM,GAAGjB,CAAC,CAACH,OAAO,CACrBU,KAAK,CAAC,GAAG,CAAC,CAEVW,MAAM,CAAC,UAACC,IAAI;IAAA,OAAK,IAAAjF,UAAA,CAAAkF,cAAc,EAACD,IAAI,CAAC,IAAI,IAAI;EAAA,EAAC;EACjD,IAAInB,CAAC,CAACgB,MAAM,KAAK,OAAO,EAAE;IACxBC,MAAM,CAACpD,IAAI,CAAC,OAAO,CAAC;;EAGtB,IAAMwD,MAAM,GAAGpB,CAAC,CAACJ,OAAO,CAACU,KAAK,CAAC,GAAG,CAAC,CAACW,MAAM,CAAC,UAACC,IAAI;IAAA,OAAK,IAAAjF,UAAA,CAAAkF,cAAc,EAACD,IAAI,CAAC,IAAI,IAAI;EAAA,EAAC;EAClF,IAAIlB,CAAC,CAACe,MAAM,KAAK,OAAO,EAAE;IACxBK,MAAM,CAACxD,IAAI,CAAC,OAAO,CAAC;;EAGtB,KAAK,IAAIwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACC,GAAG,CAACN,MAAM,CAAC1E,MAAM,EAAE8E,MAAM,CAAC9E,MAAM,CAAC,EAAE8D,CAAC,EAAE,EAAE;IAE/D,IAAIY,MAAM,CAACZ,CAAC,CAAC,IAAI,IAAI,EAAE;MACrB,OAAO,CAAC;;IAGV,IAAIgB,MAAM,CAAChB,CAAC,CAAC,IAAI,IAAI,EAAE;MACrB,OAAO,CAAC,CAAC;;IAGX,IAAMmB,SAAS,GAAGP,MAAM,CAACZ,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IAC3C,IAAMc,SAAS,GAAGJ,MAAM,CAAChB,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IAE3C,IAAIa,SAAS,IAAIC,SAAS,EAAE;MAC1B,IAAMC,SAAS,GAAGT,MAAM,CAACZ,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MACnD,IAAMkB,SAAS,GAAGN,MAAM,CAAChB,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MAEnD,IAAIiB,SAAS,IAAIC,SAAS,EAAE;QAC1B;OACD,MAAM,IAAID,SAAS,EAAE;QACpB,OAAO,CAAC;OACT,MAAM,IAAIC,SAAS,EAAE;QACpB,OAAO,CAAC,CAAC;;MAEX;;IAGF,IAAIH,SAAS,EAAE;MACb,OAAO,CAAC;;IAGV,IAAIC,SAAS,EAAE;MACb,OAAO,CAAC,CAAC;;IAGX,IAAMG,KAAK,GAAGX,MAAM,CAACZ,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IACvC,IAAMkB,KAAK,GAAGR,MAAM,CAAChB,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IAEvC,IAAIiB,KAAK,IAAIC,KAAK,EAAE;MAClB,IAAMH,UAAS,GAAGT,MAAM,CAACZ,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MACnD,IAAMkB,UAAS,GAAGN,MAAM,CAAChB,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MAEnD,IAAIiB,UAAS,IAAIC,UAAS,EAAE;QAC1B;OACD,MAAM,IAAID,UAAS,EAAE;QACpB,OAAO,CAAC;OACT,MAAM,IAAIC,UAAS,EAAE;QACpB,OAAO,CAAC,CAAC;;MAGX;;IAGF,IAAIC,KAAK,EAAE;MACT,OAAO,CAAC;;IAGV,IAAIC,KAAK,EAAE;MACT,OAAO,CAAC,CAAC;;;EAMb,IAAI7B,CAAC,CAACjB,SAAS,IAAI,CAACkB,CAAC,CAAClB,SAAS,EAAE;IAC/B,OAAO,CAAC,CAAC;;EAEX,IAAI,CAACiB,CAAC,CAACjB,SAAS,IAAIkB,CAAC,CAAClB,SAAS,EAAE;IAC/B,OAAO,CAAC;;EAGV,OAAOsC,MAAM,CAAC9E,MAAM,GAAG0E,MAAM,CAAC1E,MAAM;AACtC;AAEA,SAASuF,gCAAgCA,CACvC1F,IAAY,EACZmB,OAAsB,EACtBD,aAAmC;EAAA,IAAAyE,IAAA,EAAAC,eAAA;EAMnC,IAAMC,SAAS,GAAG1E,OAAO,CACtB2D,MAAM,CAAC,UAACrC,MAAM;IAAA,OAAK,CAACA,MAAM,CAACkB,WAAW;EAAA,EAAC,CACvC7B,GAAG,CAAC,UAACgE,KAAK,EAAI;IACb,OAAApD,aAAA,CAAAA,aAAA,KACKoD,KAAK;MAGR9F,IAAI,EAAE,IAAAF,UAAA,CAAAiG,0BAA0B,EAACD,KAAK,CAAC9F,IAAI;IAAC;EAEhD,CAAC,CAAC;EAEJ,IAAMqE,KAAK,IAAAsB,IAAA,IAAAC,eAAA,GACTC,SAAS,CAACG,IAAI,CACZ,UAACvD,MAAM;IAAA,OAELA,MAAM,CAACzC,IAAI,KAAK,EAAE,KAAK,CAACyC,MAAM,CAACc,KAAK,IAAId,MAAM,CAACc,KAAK,CAAC0C,IAAI,CAAC,EAAE,CAAC,CAAC;EAAA,EACjE,YAAAL,eAAA,GACDC,SAAS,CAACG,IAAI,CACZ,UAACvD,MAAM;IAAA,OAELA,MAAM,CAACzC,IAAI,CAACuE,UAAU,CAAC,GAAG,CAAC,IAAI9B,MAAM,CAACc,KAAM,CAAC0C,IAAI,CAAC,EAAE,CAAC;EAAA,EACxD,YAAAN,IAAA,GAGDE,SAAS,CAACG,IAAI,CAAC,UAACvD,MAAM;IAAA,OAAKA,MAAM,CAACzC,IAAI,CAACuE,UAAU,CAAC,GAAG,CAAC,IAAI9B,MAAM,CAACc,KAAM,CAAC0C,IAAI,CAAC,GAAG,CAAC;EAAA,EAAC;EAEpF,IAAI,CAAC5B,KAAK,EAAE;IACV,OAAOjE,SAAS;;EAGlB,IAAM8F,MAAM,GAAG7B,KAAK,CAACxB,UAAU,CAACf,GAAG,CAAC,UAACqE,IAAI,EAAI;IAC3C,IAAI,CAAC9B,KAAK,CAAC+B,MAAM,EAAE;MACjB,OAAO;QAAED,IAAI,EAAJA;MAAI,CAAE;;IAEjB,OAAO;MACLA,IAAI,EAAJA,IAAI;MACJC,MAAM,EAAE/B,KAAK,CAAC+B;KACf;EACH,CAAC,CAAC;EAEF,OAAOC,uBAAuB,CAACrG,IAAI,EAAEkG,MAAM,EAAE/E,OAAO,EAAED,aAAa,CAAC;AACtE;AAEA,SAASE,2BAA2BA,CAClCpB,IAAY,EACZmB,OAAsB,EACtBD,aAAmC;EAEnC,IAAMoF,cAAc,GAAGvG,oCAAoC,CAACC,IAAI,CAAC;EAEjE,IAAIsG,cAAc,CAAC9F,mBAAmB,KAAK,GAAG,EAAE;IAC9C,OAAOkF,gCAAgC,CACrCY,cAAc,CAAC7F,wBAAwB,EACvCU,OAAO,EACPD,aAAa,CACd;;EAKH,IAAMgF,MAAM,GAAGK,mBAAmB,CAACD,cAAc,CAAC9F,mBAAmB,EAAEW,OAAO,CAAC;EAE/E,IAAI+E,MAAM,IAAI,IAAI,EAAE;IAClB,OAAO9F,SAAS;;EAGlB,OAAOiG,uBAAuB,CAC5BC,cAAc,CAAC7F,wBAAwB,EACvCyF,MAAM,EACN/E,OAAO,EACPD,aAAa,CACd;AACH;AAEA,IAAMkB,SAAS,GAAG,SAAZA,SAASA,CAAA;EAAA,IAAAoE,KAAA;EAAA,SAAAC,IAAA,GAAAvG,SAAA,CAAAC,MAAA,EAAOuG,KAAe,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAAfF,KAAe,CAAAE,IAAA,IAAA1G,SAAA,CAAA0G,IAAA;EAAA;EAAA,OAClC,CAAAJ,KAAA,KAAe,EACbjE,MAAM,CAAAF,KAAA,CAAAmE,KAAA,EAAAlE,kBAAA,CAAIoE,KAAK,CAAC5E,GAAG,CAAC,UAAC+E,CAAC;IAAA,OAAKA,CAAC,CAAC1C,KAAK,CAAC,GAAG,CAAC;EAAA,EAAC,EAAC,CACzCW,MAAM,CAACgC,OAAO,CAAC,CACfhE,IAAI,CAAC,GAAG,CAAC;AAAA;AAEd,SAASyD,mBAAmBA,CAACQ,SAAiB,EAAE5F,OAAsB;EACpE,IAAI+E,MAAiC;EACrC,IAAIc,aAAa,GAAGD,SAAS;EAAC,IAAAE,KAAA,YAAAA,MAAAxE,MAAA,EAGA;MAAA,IAAAyE,eAAA;MAC5B,IAAI,CAACzE,MAAM,CAACc,KAAK,EAAE;QAAA;;MAInB,IAAMc,KAAK,GAAG2C,aAAa,CAAC3C,KAAK,CAAC5B,MAAM,CAACc,KAAK,CAAC;MAG/C,IAAI,CAACc,KAAK,EAAE;QAAA;;MAKZ,IAAM8C,aAAa,IAAAD,eAAA,GAAGzE,MAAM,CAACgB,OAAO,qBAAdyD,eAAA,CAClB/C,KAAK,CAAC,GAAG,CAAC,CACXW,MAAM,CAAC,UAAC+B,CAAC;QAAA,OAAKA,CAAC,CAACxC,KAAK,CAAC,OAAO,CAAC;MAAA,EAAC,CAC/BnB,MAAM,CAAsB,UAACC,GAAG,EAAE0D,CAAC,EAAE5C,CAAC,EAAI;QAAA,IAAAmD,MAAA;QACzC,IAAIP,CAAC,CAACxC,KAAK,CAAC,KAAK,CAAC,EAAE;UAClB,OAAA3B,aAAA,CAAAA,aAAA,KACKS,GAAG,OAAAuB,eAAA,KACLmC,CAAC,EAAGxC,KAAM,CAAC,CAACJ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;;QAG5B,OAAOrC,MAAM,CAAC6C,MAAM,CAACtB,GAAG,EAAAuB,eAAA,KAGrBmC,CAAC,GAAAO,MAAA,GAAG/C,KAAM,CAAC,CAACJ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,qBAAnBmD,MAAA,CAAqBxG,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAC5C,CAAC;MACJ,CAAC,EAAE,EAAE,CAAC;MAER,IAAMyG,aAAa,GAAG,SAAhBA,aAAaA,CAAIlB,IAAY,EAAI;QACrC,IAAM1D,MAAM,GAAGtB,OAAO,CAAC6E,IAAI,CAAC,UAACsB,CAAC;UAAA,OAAKA,CAAC,CAAC1C,MAAM,KAAKuB,IAAI;QAAA,EAAC;QACrD,IAAI,EAAC1D,MAAM,YAANA,MAAM,CAAEzC,IAAI,GAAE;UACjB,OAAO;YAAEmG,IAAI,EAAJA;UAAI,CAAE;;QAGjB,IAAMoB,QAAQ,GAAG9E,MAAM,CAACzC,IAAI,CAACmE,KAAK,CAAC,GAAG,CAAC;QAEvC,IAAMqD,MAAM,GAAwB,EAAE;QAEtCD,QAAQ,CACLzC,MAAM,CAAC,UAAC+B,CAAC;UAAA,OAAKA,CAAC,CAACxC,KAAK,CAAC,OAAO,CAAC;QAAA,EAAC,CAC/BoD,OAAO,CAAC,UAACZ,CAAC,EAAI;UACb,IAAIf,KAAK,GAAGqB,aAAa,CAACN,CAAC,CAAC;UAC5B,IAAIf,KAAK,EAAE;YAAA,IAAA4B,aAAA;YACT,IAAIb,CAAC,CAACxC,KAAK,CAAC,KAAK,CAAC,EAAE;cAAA,IAAAsD,MAAA;cAElB7B,KAAK,IAAA6B,MAAA,GAAG7B,KAAK,qBAAL6B,MAAA,CAAOxD,KAAK,CAAC,GAAG,CAAC,CAACW,MAAM,CAACgC,OAAO,CAAC;;YAG3C,IAAM/E,GAAG,GAAG8E,CAAC,CAACjG,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;YACrD4G,MAAM,CAACzF,GAAG,CAAC,GAAG,CAAA2F,aAAA,GAAAjF,MAAM,CAACmF,KAAK,aAAZF,aAAA,CAAe3F,GAAG,CAAC,GAAGU,MAAM,CAACmF,KAAK,CAAC7F,GAAG,CAAC,CAAC+D,KAAK,CAAC,GAAGA,KAAK;;QAExE,CAAC,CAAC;QAEJ,IAAI0B,MAAM,IAAI5F,MAAM,CAACC,IAAI,CAAC2F,MAAM,CAAC,CAACrH,MAAM,EAAE;UACxC,OAAO;YAAEgG,IAAI,EAAJA,IAAI;YAAEqB,MAAM,EAANA;UAAM,CAAE;;QAGzB,OAAO;UAAErB,IAAI,EAAJA;QAAI,CAAE;MACjB,CAAC;MAEDD,MAAM,GAAGzD,MAAM,CAACI,UAAU,CAACf,GAAG,CAAC,UAACqE,IAAI,EAAI;QACtC,IAAI,CAAC1D,MAAM,CAAC2D,MAAM,EAAE;UAClB,OAAA1D,aAAA,KAAY2E,aAAa,CAAClB,IAAI,CAAC;;QAEjC,OAAAzD,aAAA,CAAAA,aAAA,KACK2E,aAAa,CAAClB,IAAI,CAAC;UACtBC,MAAM,EAAE3D,MAAM,CAAC2D;QAAM;MAEzB,CAAC,CAAC;MAGF,IAAMyB,cAAc,GAAG3B,MAAM,CAAChD,MAAM,CAClC,UAACC,GAAG,EAAE2E,CAAC;QAAA,OAAKlG,MAAM,CAAC6C,MAAM,CAACtB,GAAG,EAAE2E,CAAC,CAACN,MAAM,CAAC;MAAA,GACxC,EAAE,CACH;MAED,IAAMO,iBAAiB,GAAGnG,MAAM,CAACC,IAAI,CAACgG,cAAc,CAAC,CAAC1H,MAAM,GAAG,CAAC;MAGhE+F,MAAM,GAAGA,MAAM,CAACpE,GAAG,CAAC,UAACgG,CAAC,EAAI;QACxB,IAAIC,iBAAiB,EAAE;UACrBD,CAAC,CAACN,MAAM,GAAGK,cAAc;;QAE3B,OAAOC,CAAC;MACV,CAAC,CAAC;MAEFd,aAAa,GAAGA,aAAa,CAACpG,OAAO,CAACyD,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MAAC;KAGrD;IAAA2D,IAAA;EA3FD,KAAK,IAAMvF,MAAM,IAAItB,OAAO;IAAA6G,IAAA,GAAAf,KAAA,CAAAxE,MAAA;IAAA,IAAAuF,IAAA,QAExB;IAAS,IAAAA,IAAA,QAwFX;EAAM;EAGR,OAAO9B,MAAM;AACf;AAEA,SAAS+B,aAAaA,CAACrE,CAAW,EAAEC,CAAW;EAC7C,IAAID,CAAC,CAACzD,MAAM,KAAK0D,CAAC,CAAC1D,MAAM,EAAE;IACzB,OAAO,KAAK;;EAEd,KAAK,IAAI8D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,CAACzD,MAAM,EAAE8D,CAAC,EAAE,EAAE;IACjC,IAAIL,CAAC,CAACK,CAAC,CAAC,CAACU,aAAa,CAACd,CAAC,CAACI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MAClC,OAAO,KAAK;;;EAGhB,OAAO,IAAI;AACb;AAEA,IAAMjC,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAC3B4C,MAAc,EACdsD,WAAkC,EAKjB;EAAA,IAJjBrF,UAAA,GAAA3C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAuB,EAAE;EAAA,IACzBiI,QAAA,GAAAjI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiC,EAAE;EAAA,IACnCwB,aAAA,GAAAxB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,EAAE;EAAA,IAC5BkI,aAAsB,GAAAlI,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAEtB,IAAMe,OAAO,GAAkB,EAAE;EAEjC0B,UAAU,CAACpB,IAAI,CAACmD,MAAM,CAAC;EAEvBlD,aAAa,CAACD,IAAI,CAACmD,MAAM,CAAC;EAE1B,IAAMnC,MAAM,GAAIyF,WAAmB,CAACtD,MAAM,CAAC;EAE3C,IAAI,OAAOnC,MAAM,KAAK,QAAQ,EAAE;IAI9B,IAAMgB,OAAO,GAAG2E,aAAa,GAAGhG,SAAS,CAACgG,aAAa,EAAE3F,MAAM,CAAC,GAAGA,MAAM;IAEzEtB,OAAO,CAACM,IAAI,CAAC4G,gBAAgB,CAACzD,MAAM,EAAE/B,UAAU,EAAEY,OAAO,EAAEhB,MAAM,EAAE,KAAK,CAAC,CAAC;GAC3E,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACrC,IAAIgB,QAA2B;IAE/B,IAAQ2C,MAAM,GAAK3D,MAAM,CAAjB2D,MAAM;IAId,IAAI,OAAO3D,MAAM,CAACzC,IAAI,KAAK,QAAQ,EAAE;MAAA,IAAAsI,YAAA;MACnC,IAAI7F,MAAM,CAAC8F,KAAK,IAAI9F,MAAM,CAACzC,IAAI,KAAKI,SAAS,EAAE;QAC7C,MAAM,IAAImB,KAAK,CACb,sJAAsJ,CACvJ;;MAGHkC,QAAO,GACLhB,MAAM,CAAC8F,KAAK,KAAK,IAAI,GACjBnG,SAAS,CAACgG,aAAa,IAAI,EAAE,EAAE3F,MAAM,CAACzC,IAAI,IAAI,EAAE,CAAC,GACjDyC,MAAM,CAACzC,IAAI,IAAI,EAAE;MAEvBmB,OAAO,CAACM,IAAI,CACV4G,gBAAgB,CACdzD,MAAM,EACN/B,UAAU,EACVY,QAAQ,EACRhB,MAAM,CAACzC,IAAI,EACXyC,MAAM,CAACnB,OAAO,GAAG,CAAC,GAAAgH,YAAA,GAAC1G,MAAM,CAACC,IAAI,CAACY,MAAM,CAACnB,OAAO,CAAC,aAA3BgH,YAAA,CAA6BnI,MAAM,IAAG,KAAK,EAC9DsC,MAAM,CAACmF,KAAK,EACZxB,MAAM,CACP,CACF;;IAGH,IAAI3D,MAAM,CAACnB,OAAO,EAAE;MAElB,IAAImB,MAAM,CAACjB,gBAAgB,EAAE;QAC3B2G,QAAQ,CAAC1G,IAAI,CAAC;UACZD,gBAAgB,EAAEiB,MAAM,CAACjB,gBAAgB;UACzCE,aAAa,EAAbA;SACD,CAAC;;MAGJE,MAAM,CAACC,IAAI,CAACY,MAAM,CAACnB,OAAO,CAAC,CAACmG,OAAO,CAAC,UAACe,YAAY,EAAI;QAAA,IAAAC,SAAA;QACnD,IAAMC,MAAM,GAAG1G,uBAAuB,CACpCwG,YAAY,EACZ/F,MAAM,CAACnB,OAAgC,EACvCuB,UAAU,EACVsF,QAAQ,EAAA7F,kBAAA,CACJZ,aAAa,IAAA+G,SAAA,GACjBhF,QAAO,YAAAgF,SAAA,GAAIL,aAAa,CACzB;QAEDjH,OAAO,CAACM,IAAI,CAAAY,KAAA,CAAZlB,OAAO,EAAAmB,kBAAA,CAASoG,MAAM,EAAC;MACzB,CAAC,CAAC;;;EAIN7F,UAAU,CAACuB,GAAG,EAAE;EAEhB,OAAOjD,OAAO;AAChB,CAAC;AAED,SAASwH,kBAAkBA,CAAC3E,EAAU;EAEpCA,EAAE,GAAGA,EAAE,CAACpD,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC;EAE3B,IAAIoD,EAAE,CAACO,UAAU,CAAC,GAAG,CAAC,EAAE;IAEtB,OAAO,cAAcP,EAAE,CAAC4E,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG;GACpD,MAAM,IAAI5E,EAAE,CAACO,UAAU,CAAC,GAAG,CAAC,EAAE;IAC7B,OAAO,WAAWP,EAAE,CAAC4E,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG;;EAIlD,IAAI,IAAA9I,UAAA,CAAAkF,cAAc,EAAChB,EAAE,CAAC,IAAI,IAAI,EAAE;IAI9B,OAAO,MAAM,IAAAvE,sBAAA,CAAA4B,OAAM,EAAC2C,EAAE,CAAC,OAAO;;EAGhC,OAAO,IAAAvE,sBAAA,CAAA4B,OAAM,EAAC2C,EAAE,CAAC,GAAG,KAAK;AAC3B;AAEA,IAAMqE,gBAAgB,GAAG,SAAnBA,gBAAgBA,CACpBzD,MAAc,EACd/B,UAAoB,EACpBY,OAAe,EACfzD,IAAY,EACZ2D,WAAqB,EACrBiE,KAAmB,EACnBxB,MAAY,EACG;EAEf3C,OAAO,GAAGA,OAAO,CAACU,KAAK,CAAC,GAAG,CAAC,CAACW,MAAM,CAACgC,OAAO,CAAC,CAAChE,IAAI,CAAC,GAAG,CAAC;EAEtD,IAAMS,KAAK,GAAGE,OAAO,GACjB,IAAIoF,MAAM,CAAC,KAAKpF,OAAO,CAACU,KAAK,CAAC,GAAG,CAAC,CAACrC,GAAG,CAAC6G,kBAAkB,CAAC,CAAC7F,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GACxE1C,SAAS;EAEb,OAAO;IACLwE,MAAM,EAANA,MAAM;IACNrB,KAAK,EAALA,KAAK;IACLE,OAAO,EAAPA,OAAO;IACPzD,IAAI,EAAJA,IAAI;IAEJ6C,UAAU,EAAAP,kBAAA,CAAMO,UAAU,CAAC;IAC3B+E,KAAK,EAALA,KAAK;IACLpD,gBAAgB,EAAE,GAAAjC,MAAA,CAAAD,kBAAA,CAAIO,UAAU,CAACiG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAE9I,IAAI,IAAI4E,MAAM,GAAE9B,IAAI,CAAC,GAAG,CAAC;IACxEa,WAAW,EAAE,CAAC,CAACA,WAAW;IAC1ByC,MAAM,EAANA;GACD;AACH,CAAC;AAED,IAAM2C,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAC3BC,SAAiB,EACjBC,YAA2B,EACA;EAC3B,KAAK,IAAMxG,MAAM,IAAIwG,YAAY,EAAE;IACjC,IAAID,SAAS,KAAKvG,MAAM,CAACI,UAAU,CAACJ,MAAM,CAACI,UAAU,CAAC1C,MAAM,GAAG,CAAC,CAAC,EAAE;MACjE,OAAOsC,MAAM,CAACmF,KAAK;;;EAIvB,OAAOxH,SAAS;AAClB,CAAC;AAGD,IAAM8I,gBAAgB,GAAG,SAAnBA,gBAAgBA,CACpBF,SAAiB,EACjBtH,aAAuB,EACvBR,aAAmC,EACb;EACtB,KAAK,IAAMuB,MAAM,IAAIvB,aAAa,EAAE;IAClC,IAAI+G,aAAa,CAACvG,aAAa,EAAEe,MAAM,CAACf,aAAa,CAAC,EAAE;MAGtD,OAAOsH,SAAS,KAAKvG,MAAM,CAACjB,gBAAgB,GAAGiB,MAAM,CAACjB,gBAAgB,GAAGpB,SAAS;;;EAGtF,OAAOA,SAAS;AAClB,CAAC;AAID,IAAM+I,iBAAiB,GAAG,SAApBA,iBAAiBA,CACrBC,YAAgC,EAChCjH,KAAkB,EAClBkH,OAAgB,EACA;EAChB,IAAIA,OAAO,EAAE;IACX,IAAID,YAAY,EAAE;MAChB,OAAO;QACLE,KAAK,EAAE,CAAC;QACRpD,MAAM,EAAE,CAAC;UAAEC,IAAI,EAAEiD;QAAY,CAAE,EAAEjH,KAAK;OACvC;;IAEH,OAAO;MACL+D,MAAM,EAAE,CAAC/D,KAAK;KACf;;EAGH,IAAIiH,YAAY,EAAE;IAChB,OAAO;MACLE,KAAK,EAAE,CAAC;MACRpD,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAEiD;MAAY,CAAE,EAAA1G,aAAA,CAAAA,aAAA,KAAOP,KAAK;QAAEoH,KAAK,EAAE;UAAErD,MAAM,EAAE;QAAE;MAAE;KACnE;;EAEH,OAAO;IACLA,MAAM,EAAE,CAAAxD,aAAA,CAAAA,aAAA,KAAMP,KAAK;MAAEoH,KAAK,EAAE;QAAErD,MAAM,EAAE;MAAE;IAAE;GAC3C;AACH,CAAC;AAED,IAAMG,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAC3BrG,IAAY,EACZkG,MAAqB,EACrB+C,YAA2B,EAC3B/H,aAAmC,EACjC;EACF,IAAIiB,KAAK,GAAG+D,MAAM,CAACsD,KAAK,EAAiB;EACzC,IAAM9H,aAAa,GAAa,EAAE;EAElC,IAAI0H,YAAY,GAAGF,gBAAgB,CAAC/G,KAAK,CAACgE,IAAI,EAAEzE,aAAa,EAAER,aAAa,CAAC;EAE7EQ,aAAa,CAACD,IAAI,CAACU,KAAK,CAACgE,IAAI,CAAC;EAE9B,IAAMoD,KAAK,GAAiBJ,iBAAiB,CAACC,YAAY,EAAEjH,KAAK,EAAE+D,MAAM,CAAC/F,MAAM,KAAK,CAAC,CAAC;EAEvF,IAAI+F,MAAM,CAAC/F,MAAM,GAAG,CAAC,EAAE;IACrB,IAAIsJ,WAAW,GAAGF,KAAK;IAEvB,OAAQpH,KAAK,GAAG+D,MAAM,CAACsD,KAAK,EAAiB,EAAG;MAC9CJ,YAAY,GAAGF,gBAAgB,CAAC/G,KAAK,CAACgE,IAAI,EAAEzE,aAAa,EAAER,aAAa,CAAC;MAEzE,IAAMwI,gBAAgB,GAAGD,WAAW,CAACH,KAAK,IAAIG,WAAW,CAACvD,MAAM,CAAC/F,MAAM,GAAG,CAAC;MAE3EsJ,WAAW,CAACvD,MAAM,CAACwD,gBAAgB,CAAC,CAACH,KAAK,GAAGJ,iBAAiB,CAC5DC,YAAY,EACZjH,KAAK,EACL+D,MAAM,CAAC/F,MAAM,KAAK,CAAC,CACpB;MAED,IAAI+F,MAAM,CAAC/F,MAAM,GAAG,CAAC,EAAE;QACrBsJ,WAAW,GAAGA,WAAW,CAACvD,MAAM,CAACwD,gBAAgB,CAAC,CAACH,KAAqB;;MAG1E7H,aAAa,CAACD,IAAI,CAACU,KAAK,CAACgE,IAAI,CAAC;;;EAIlChE,KAAK,GAAG,IAAAvC,kBAAA,CAAA+J,gBAAgB,EAACJ,KAAK,CAAgB;EAG9CpH,KAAK,CAACnC,IAAI,GAAG,IAAAF,UAAA,CAAAiG,0BAA0B,EAAC/F,IAAI,CAAC;EAE7C,IAAMwH,MAAM,GAAGoC,gBAAgB,CAACzH,KAAK,CAACnC,IAAI,EAAE+I,uBAAuB,CAAC5G,KAAK,CAACgE,IAAI,EAAE8C,YAAY,CAAC,CAAC;EAE9F,IAAIzB,MAAM,EAAE;IACVrF,KAAK,CAACqF,MAAM,GAAG5F,MAAM,CAAC6C,MAAM,CAAC7C,MAAM,CAACiI,MAAM,CAAC,IAAI,CAAC,EAAE1H,KAAK,CAACqF,MAAM,CAAwB;IACtF,SAAAsC,KAAA,IAA4BlI,MAAM,CAACmI,OAAO,CAACvC,MAAM,CAAC,EAAE;MAAA,IAAAwC,aAAA,EAAAC,cAAA;MAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAL,KAAA;MAAA,IAAxC3D,IAAI,GAAA+D,KAAA;MAAA,IAAEpE,KAAK,GAAAoE,KAAA;MACrB,KAAAF,aAAA,GAAI7H,KAAK,CAACqF,MAAM,aAAZwC,aAAA,CAAe7D,IAAI,CAAC,EAAE;QACxB,IAAIiE,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzCC,OAAO,CAACC,IAAI,CACV,WAAWrI,KAAK,CAACgE,IAAI,iBAAiBA,IAAI,qEAAqE,CAChH;;;MAIL,IAAI,GAAA8D,cAAA,GAAC9H,KAAK,CAACqF,MAAM,aAAZyC,cAAA,CAAe9D,IAAI,CAAC,GAAE;QACzBhE,KAAK,CAACqF,MAAM,CAACrB,IAAI,CAAC,GAAGL,KAAK;QAC1B;;;IAIJ,IAAIlE,MAAM,CAACC,IAAI,CAACM,KAAK,CAACqF,MAAM,CAAC,CAACrH,MAAM,KAAK,CAAC,EAAE;MAC1C,OAAOgC,KAAK,CAACqF,MAAM;;;EAIvB,OAAO+B,KAAK;AACd,CAAC;AAED,IAAMK,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAI5J,IAAY,EAAEyK,WAAoD,EAAI;EAC9F,IAAMC,KAAK,GAAG1K,IAAI,CAACmE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAChC,IAAMwG,YAAY,GAAG,IAAIC,eAAe,CAACF,KAAK,CAAC;EAC/C,IAAMlD,MAAM,GAAG5F,MAAM,CAACiJ,WAAW,CAE/BF,YAAY,CACb;EAED,IAAIF,WAAW,EAAE;IACf7I,MAAM,CAACC,IAAI,CAAC2F,MAAM,CAAC,CAACC,OAAO,CAAC,UAACtB,IAAI,EAAI;MACnC,IAAIvE,MAAM,CAACkJ,cAAc,CAACC,IAAI,CAACN,WAAW,EAAEtE,IAAI,CAAC,IAAI,OAAOqB,MAAM,CAACrB,IAAI,CAAC,KAAK,QAAQ,EAAE;QACrFqB,MAAM,CAACrB,IAAI,CAAC,GAAGsE,WAAW,CAACtE,IAAI,CAAC,CAACqB,MAAM,CAACrB,IAAI,CAAW,CAAC;;IAE5D,CAAC,CAAC;;EAGJ,OAAOvE,MAAM,CAACC,IAAI,CAAC2F,MAAM,CAAC,CAACrH,MAAM,GAAGqH,MAAM,GAAGpH,SAAS;AACxD,CAAC;AAED,IAAM4K,YAAY,GAAG,IAAIC,GAAG,EAAkB;AAE9C,SAASC,eAAeA,CAACjL,OAAe;EACtC,IAAI+K,YAAY,CAACG,GAAG,CAAClL,OAAO,CAAC,EAAE;IAC7B,OAAO+K,YAAY,CAACI,GAAG,CAACnL,OAAO,CAAE;;EAEnC,IAAMsD,KAAK,GAAG,IAAIsF,MAAM,CAAC,QAAQ,IAAApJ,sBAAA,CAAA4B,OAAM,EAACpB,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC;EACxD+K,YAAY,CAACK,GAAG,CAACpL,OAAO,EAAEsD,KAAK,CAAC;EAChC,OAAOA,KAAK;AACd;AAEA,SAAgB5C,YAAYA,CAC1BX,IAAY,EAC2C;EAAA,IAAvDC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;EAEA,IAAIkK,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IAC1C,IAAIrK,OAAO,EAAE;MACX,IAAMqL,GAAG,GAAGJ,eAAe,CAACjL,OAAO,CAAC;MACpC,OAAOD,IAAI,CAACY,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC0K,GAAG,EAAE,EAAE,CAAC;;;EAGtD,OAAOtL,IAAI;AACb;AAXAa,OAAA,CAAAF,YAAA,GAAAA,YAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}