{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useInitializeExpoRouter = exports.useStoreRouteInfo = exports.useStoreRootState = exports.useExpoRouter = exports.store = exports.RouterStore = void 0;\nvar native_1 = require(\"@react-navigation/native\");\nvar SplashScreen = __importStar(require(\"expo-splash-screen\"));\nvar react_1 = require(\"react\");\nvar routing_1 = require(\"./routing\");\nvar sort_routes_1 = require(\"./sort-routes\");\nvar LocationProvider_1 = require(\"../LocationProvider\");\nvar getPathFromState_1 = require(\"../fork/getPathFromState\");\nvar getLinkingConfig_1 = require(\"../getLinkingConfig\");\nvar getRoutes_1 = require(\"../getRoutes\");\nvar useScreens_1 = require(\"../useScreens\");\nvar RouterStore = function () {\n  function RouterStore() {\n    var _this = this;\n    _classCallCheck(this, RouterStore);\n    this.hasAttemptedToHideSplash = false;\n    this.rootStateSubscribers = new Set();\n    this.storeSubscribers = new Set();\n    this.linkTo = routing_1.linkTo.bind(this);\n    this.getSortedRoutes = sort_routes_1.getSortedRoutes.bind(this);\n    this.goBack = routing_1.goBack.bind(this);\n    this.canGoBack = routing_1.canGoBack.bind(this);\n    this.push = routing_1.push.bind(this);\n    this.dismiss = routing_1.dismiss.bind(this);\n    this.replace = routing_1.replace.bind(this);\n    this.dismissAll = routing_1.dismissAll.bind(this);\n    this.canDismiss = routing_1.canDismiss.bind(this);\n    this.setParams = routing_1.setParams.bind(this);\n    this.navigate = routing_1.navigate.bind(this);\n    this.subscribeToRootState = function (subscriber) {\n      _this.rootStateSubscribers.add(subscriber);\n      return function () {\n        return _this.rootStateSubscribers.delete(subscriber);\n      };\n    };\n    this.subscribeToStore = function (subscriber) {\n      _this.storeSubscribers.add(subscriber);\n      return function () {\n        return _this.storeSubscribers.delete(subscriber);\n      };\n    };\n    this.snapshot = function () {\n      return _this;\n    };\n    this.rootStateSnapshot = function () {\n      return _this.rootState;\n    };\n    this.routeInfoSnapshot = function () {\n      return _this.routeInfo;\n    };\n  }\n  return _createClass(RouterStore, [{\n    key: \"initialize\",\n    value: function initialize(context, navigationRef, initialLocation) {\n      var _this$navigationRefSu,\n        _this2 = this;\n      this.initialState = undefined;\n      this.rootState = undefined;\n      this.nextState = undefined;\n      this.routeInfo = undefined;\n      this.linking = undefined;\n      (_this$navigationRefSu = this.navigationRefSubscription) == null ? void 0 : _this$navigationRefSu.call(this);\n      this.rootStateSubscribers.clear();\n      this.storeSubscribers.clear();\n      this.routeNode = (0, getRoutes_1.getRoutes)(context, {\n        ignoreEntryPoints: true\n      });\n      this.rootComponent = this.routeNode ? (0, useScreens_1.getQualifiedRouteComponent)(this.routeNode) : react_1.Fragment;\n      if (!this.routeNode && process.env.NODE_ENV === 'production') {\n        throw new Error('No routes found');\n      }\n      this.navigationRef = navigationRef;\n      if (this.routeNode) {\n        this.linking = (0, getLinkingConfig_1.getLinkingConfig)(this.routeNode);\n        if (initialLocation) {\n          var _this$linking$getStat, _this$linking;\n          this.linking.getInitialURL = function () {\n            return initialLocation.toString();\n          };\n          this.initialState = (_this$linking$getStat = (_this$linking = this.linking).getStateFromPath) == null ? void 0 : _this$linking$getStat.call(_this$linking, initialLocation.pathname + initialLocation.search, this.linking.config);\n        }\n      }\n      if (this.initialState) {\n        this.rootState = this.initialState;\n        this.routeInfo = this.getRouteInfo(this.initialState);\n      } else {\n        this.routeInfo = {\n          unstable_globalHref: '',\n          pathname: '',\n          isIndex: false,\n          params: {},\n          segments: []\n        };\n      }\n      this.navigationRefSubscription = navigationRef.addListener('state', function (data) {\n        var state = data.data.state;\n        if (!_this2.hasAttemptedToHideSplash) {\n          _this2.hasAttemptedToHideSplash = true;\n          requestAnimationFrame(function () {\n            return SplashScreen._internal_maybeHideAsync == null ? void 0 : SplashScreen._internal_maybeHideAsync();\n          });\n        }\n        var shouldUpdateSubscribers = _this2.nextState === state;\n        _this2.nextState = undefined;\n        if (state && state !== _this2.rootState) {\n          exports.store.updateState(state, undefined);\n          shouldUpdateSubscribers = true;\n        }\n        if (shouldUpdateSubscribers) {\n          for (var subscriber of _this2.rootStateSubscribers) {\n            subscriber();\n          }\n        }\n      });\n      for (var subscriber of this.storeSubscribers) {\n        subscriber();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(state) {\n      var nextState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state;\n      exports.store.rootState = state;\n      exports.store.nextState = nextState;\n      var nextRouteInfo = exports.store.getRouteInfo(state);\n      if (!(0, getPathFromState_1.deepEqual)(this.routeInfo, nextRouteInfo)) {\n        exports.store.routeInfo = nextRouteInfo;\n      }\n    }\n  }, {\n    key: \"getRouteInfo\",\n    value: function getRouteInfo(state) {\n      var _this3 = this;\n      return (0, LocationProvider_1.getRouteInfoFromState)(function (state, asPath) {\n        var _this3$linking;\n        return (0, getPathFromState_1.getPathDataFromState)(state, _objectSpread(_objectSpread({\n          screens: []\n        }, (_this3$linking = _this3.linking) == null ? void 0 : _this3$linking.config), {}, {\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath\n        }));\n      }, state);\n    }\n  }, {\n    key: \"shouldShowTutorial\",\n    value: function shouldShowTutorial() {\n      return !this.routeNode && process.env.NODE_ENV === 'development';\n    }\n  }]);\n}();\nexports.RouterStore = RouterStore;\nexports.store = new RouterStore();\nfunction useExpoRouter() {\n  return (0, react_1.useSyncExternalStore)(exports.store.subscribeToStore, exports.store.snapshot, exports.store.snapshot);\n}\nexports.useExpoRouter = useExpoRouter;\nfunction syncStoreRootState() {\n  if (exports.store.navigationRef.isReady()) {\n    var currentState = exports.store.navigationRef.getRootState();\n    if (exports.store.rootState !== currentState) {\n      exports.store.updateState(currentState);\n    }\n  }\n}\nfunction useStoreRootState() {\n  syncStoreRootState();\n  return (0, react_1.useSyncExternalStore)(exports.store.subscribeToRootState, exports.store.rootStateSnapshot, exports.store.rootStateSnapshot);\n}\nexports.useStoreRootState = useStoreRootState;\nfunction useStoreRouteInfo() {\n  syncStoreRootState();\n  return (0, react_1.useSyncExternalStore)(exports.store.subscribeToRootState, exports.store.routeInfoSnapshot, exports.store.routeInfoSnapshot);\n}\nexports.useStoreRouteInfo = useStoreRouteInfo;\nfunction useInitializeExpoRouter(context, initialLocation) {\n  var navigationRef = (0, native_1.useNavigationContainerRef)();\n  (0, react_1.useMemo)(function () {\n    return exports.store.initialize(context, navigationRef, initialLocation);\n  }, [context, initialLocation]);\n  useExpoRouter();\n  return exports.store;\n}\nexports.useInitializeExpoRouter = useInitializeExpoRouter;","map":{"version":3,"names":["native_1","require","SplashScreen","__importStar","react_1","routing_1","sort_routes_1","LocationProvider_1","getPathFromState_1","getLinkingConfig_1","getRoutes_1","useScreens_1","RouterStore","_this","_classCallCheck","hasAttemptedToHideSplash","rootStateSubscribers","Set","storeSubscribers","linkTo","bind","getSortedRoutes","goBack","canGoBack","push","dismiss","replace","dismissAll","canDismiss","setParams","navigate","subscribeToRootState","subscriber","add","delete","subscribeToStore","snapshot","rootStateSnapshot","rootState","routeInfoSnapshot","routeInfo","_createClass","key","value","initialize","context","navigationRef","initialLocation","_this$navigationRefSu","_this2","initialState","undefined","nextState","linking","navigationRefSubscription","call","clear","routeNode","getRoutes","ignoreEntryPoints","rootComponent","getQualifiedRouteComponent","Fragment","process","env","NODE_ENV","Error","getLinkingConfig","_this$linking$getStat","_this$linking","getInitialURL","toString","getStateFromPath","pathname","search","config","getRouteInfo","unstable_globalHref","isIndex","params","segments","addListener","data","state","requestAnimationFrame","_internal_maybeHideAsync","shouldUpdateSubscribers","exports","store","updateState","arguments","length","nextRouteInfo","deepEqual","_this3","getRouteInfoFromState","asPath","_this3$linking","getPathDataFromState","_objectSpread","screens","preserveDynamicRoutes","preserveGroups","shouldShowTutorial","useExpoRouter","useSyncExternalStore","syncStoreRootState","isReady","currentState","getRootState","useStoreRootState","useStoreRouteInfo","useInitializeExpoRouter","useNavigationContainerRef","useMemo"],"sources":["/Users/josh/src/ui/apps/old-demo/node_modules/expo-router/src/global-state/router-store.tsx"],"sourcesContent":["import {\n  NavigationContainerRefWithCurrent,\n  getPathFromState,\n  useNavigationContainerRef,\n} from '@react-navigation/native';\nimport * as SplashScreen from 'expo-splash-screen';\nimport { useSyncExternalStore, useMemo, ComponentType, Fragment } from 'react';\n\nimport {\n  canGoBack,\n  canDismiss,\n  goBack,\n  linkTo,\n  navigate,\n  dismiss,\n  dismissAll,\n  push,\n  replace,\n  setParams,\n} from './routing';\nimport { getSortedRoutes } from './sort-routes';\nimport { UrlObject, getRouteInfoFromState } from '../LocationProvider';\nimport { RouteNode } from '../Route';\nimport { deepEqual, getPathDataFromState } from '../fork/getPathFromState';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { ExpoLinkingOptions, getLinkingConfig } from '../getLinkingConfig';\nimport { getRoutes } from '../getRoutes';\nimport { RequireContext } from '../types';\nimport { getQualifiedRouteComponent } from '../useScreens';\n\n/**\n * This is the global state for the router. It is used to keep track of the current route, and to provide a way to navigate to other routes.\n *\n * There should only be one instance of this class and be initialized via `useInitializeExpoRouter`\n */\nexport class RouterStore {\n  routeNode!: RouteNode | null;\n  rootComponent!: ComponentType;\n  linking: ExpoLinkingOptions | undefined;\n  private hasAttemptedToHideSplash: boolean = false;\n\n  initialState: ResultState | undefined;\n  rootState: ResultState | undefined;\n  nextState: ResultState | undefined;\n  routeInfo?: UrlObject | undefined;\n\n  navigationRef!: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>;\n  navigationRefSubscription!: () => void;\n\n  rootStateSubscribers = new Set<() => void>();\n  storeSubscribers = new Set<() => void>();\n\n  linkTo = linkTo.bind(this);\n  getSortedRoutes = getSortedRoutes.bind(this);\n  goBack = goBack.bind(this);\n  canGoBack = canGoBack.bind(this);\n  push = push.bind(this);\n  dismiss = dismiss.bind(this);\n  replace = replace.bind(this);\n  dismissAll = dismissAll.bind(this);\n  canDismiss = canDismiss.bind(this);\n  setParams = setParams.bind(this);\n  navigate = navigate.bind(this);\n\n  initialize(\n    context: RequireContext,\n    navigationRef: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>,\n    initialLocation?: URL\n  ) {\n    // Clean up any previous state\n    this.initialState = undefined;\n    this.rootState = undefined;\n    this.nextState = undefined;\n    this.routeInfo = undefined;\n    this.linking = undefined;\n    this.navigationRefSubscription?.();\n    this.rootStateSubscribers.clear();\n    this.storeSubscribers.clear();\n\n    this.routeNode = getRoutes(context, { ignoreEntryPoints: true });\n\n    this.rootComponent = this.routeNode ? getQualifiedRouteComponent(this.routeNode) : Fragment;\n\n    // Only error in production, in development we will show the onboarding screen\n    if (!this.routeNode && process.env.NODE_ENV === 'production') {\n      throw new Error('No routes found');\n    }\n\n    this.navigationRef = navigationRef;\n\n    if (this.routeNode) {\n      this.linking = getLinkingConfig(this.routeNode!);\n\n      if (initialLocation) {\n        this.linking.getInitialURL = () => initialLocation.toString();\n        this.initialState = this.linking.getStateFromPath?.(\n          initialLocation.pathname + initialLocation.search,\n          this.linking.config\n        );\n      }\n    }\n\n    // There is no routeNode, so we will be showing the onboarding screen\n    // In the meantime, just mock the routeInfo\n    if (this.initialState) {\n      this.rootState = this.initialState;\n      this.routeInfo = this.getRouteInfo(this.initialState);\n    } else {\n      this.routeInfo = {\n        unstable_globalHref: '',\n        pathname: '',\n        isIndex: false,\n        params: {},\n        segments: [],\n      };\n    }\n\n    /**\n     * Counter intuitively - this fires AFTER both React Navigation's state changes and the subsequent paint.\n     * This poses a couple of issues for Expo Router,\n     *   - Ensuring hooks (e.g. useSearchParams()) have data in the initial render\n     *   - Reacting to state changes after a navigation event\n     *\n     * This is why the initial render renders a Fragment and we wait until `onReady()` is called\n     * Additionally, some hooks compare the state from both the store and the navigationRef. If the store it stale,\n     * that hooks will manually update the store.\n     *\n     */\n    this.navigationRefSubscription = navigationRef.addListener('state', (data) => {\n      const state = data.data.state as ResultState;\n\n      if (!this.hasAttemptedToHideSplash) {\n        this.hasAttemptedToHideSplash = true;\n        // NOTE(EvanBacon): `navigationRef.isReady` is sometimes not true when state is called initially.\n        requestAnimationFrame(\n          () =>\n            // @ts-expect-error: This function is native-only and for internal-use only.\n            SplashScreen._internal_maybeHideAsync?.()\n        );\n      }\n\n      let shouldUpdateSubscribers = this.nextState === state;\n      this.nextState = undefined;\n\n      // This can sometimes be undefined when an error is thrown in the Root Layout Route.\n      // Additionally that state may already equal the rootState if it was updated within a hook\n      if (state && state !== this.rootState) {\n        store.updateState(state, undefined);\n        shouldUpdateSubscribers = true;\n      }\n\n      // If the state has changed, or was changed inside a hook we need to update the subscribers\n      if (shouldUpdateSubscribers) {\n        for (const subscriber of this.rootStateSubscribers) {\n          subscriber();\n        }\n      }\n    });\n\n    for (const subscriber of this.storeSubscribers) {\n      subscriber();\n    }\n  }\n\n  updateState(state: ResultState, nextState = state) {\n    store.rootState = state;\n    store.nextState = nextState;\n\n    const nextRouteInfo = store.getRouteInfo(state);\n\n    if (!deepEqual(this.routeInfo, nextRouteInfo)) {\n      store.routeInfo = nextRouteInfo;\n    }\n  }\n\n  getRouteInfo(state: ResultState) {\n    return getRouteInfoFromState(\n      (state: Parameters<typeof getPathFromState>[0], asPath: boolean) => {\n        return getPathDataFromState(state, {\n          screens: [],\n          ...this.linking?.config,\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath,\n        });\n      },\n      state\n    );\n  }\n\n  // This is only used in development, to show the onboarding screen\n  // In production we should have errored during the initialization\n  shouldShowTutorial() {\n    return !this.routeNode && process.env.NODE_ENV === 'development';\n  }\n\n  /** Make sure these are arrow functions so `this` is correctly bound */\n  subscribeToRootState = (subscriber: () => void) => {\n    this.rootStateSubscribers.add(subscriber);\n    return () => this.rootStateSubscribers.delete(subscriber);\n  };\n  subscribeToStore = (subscriber: () => void) => {\n    this.storeSubscribers.add(subscriber);\n    return () => this.storeSubscribers.delete(subscriber);\n  };\n  snapshot = () => {\n    return this;\n  };\n  rootStateSnapshot = () => {\n    return this.rootState!;\n  };\n  routeInfoSnapshot = () => {\n    return this.routeInfo!;\n  };\n}\n\nexport const store = new RouterStore();\n\nexport function useExpoRouter() {\n  return useSyncExternalStore(store.subscribeToStore, store.snapshot, store.snapshot);\n}\n\nfunction syncStoreRootState() {\n  if (store.navigationRef.isReady()) {\n    const currentState = store.navigationRef.getRootState() as unknown as ResultState;\n\n    if (store.rootState !== currentState) {\n      store.updateState(currentState);\n    }\n  }\n}\n\nexport function useStoreRootState() {\n  syncStoreRootState();\n  return useSyncExternalStore(\n    store.subscribeToRootState,\n    store.rootStateSnapshot,\n    store.rootStateSnapshot\n  );\n}\n\nexport function useStoreRouteInfo() {\n  syncStoreRootState();\n  return useSyncExternalStore(\n    store.subscribeToRootState,\n    store.routeInfoSnapshot,\n    store.routeInfoSnapshot\n  );\n}\n\nexport function useInitializeExpoRouter(context: RequireContext, initialLocation: URL | undefined) {\n  const navigationRef = useNavigationContainerRef();\n  useMemo(\n    () => store.initialize(context, navigationRef, initialLocation),\n    [context, initialLocation]\n  );\n  useExpoRouter();\n  return store;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}